{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Code Documentation","text":"<p>Below you can find the generated API documentation grouped by functional areas of the project.</p>"},{"location":"#setup","title":"Setup","text":"<p>Handles external inputs to the simulation: - TLE (Two-Line Element Set) describing the orbit. - initial_settings.json containing simulation, satellite, sensor, actuator, and control parameters. Both resources have dedicated reader classes.</p>"},{"location":"#setup.initial_settings","title":"<code>setup.initial_settings</code>","text":""},{"location":"#setup.initial_settings.SimulationSetupReader","title":"<code>SimulationSetupReader(setup_file)</code>","text":"<p>               Bases: <code>SimulationSetup</code></p>"},{"location":"#setup.initial_settings.SimulationSetupReader.actuators_on_time","title":"<code>actuators_on_time</code>  <code>property</code>","text":"<p>Time interval for which the actuators are active. In real life conditions sensors and actuators should not work at the same time.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>on time in seconds.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.angular_velocity","title":"<code>angular_velocity</code>  <code>property</code>","text":"<p>Initial angular velocity (q, r, p) in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>q - velocity around y-axis.</p> <code>float</code> <code>ndarray</code> <p>r - velocity around z-axis.</p> <code>float</code> <code>ndarray</code> <p>p - velocity around x-axis.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.b_cross_mode","title":"<code>b_cross_mode</code>  <code>property</code>","text":"<p>B-cross mode settings.</p> <p>returns (dict):     Task (str): task mode (\"earth_pointing\" or \"sun_pointing\").     PointingAxis (np.ndarray): pointing axis.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.b_cross_parameters","title":"<code>b_cross_parameters</code>  <code>property</code>","text":"<p>B-cross control parameters.</p> <p>returns (dict):     AlignGain (float): alignment gain.     ProportionalGain (float): damping gain.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.b_dot_mode","title":"<code>b_dot_mode</code>  <code>property</code>","text":"<p>B-dot algorithm mods selection. If all are set to False the original variant will be used. Some may be combined (the proportional term may be used in the modified b-dot, the angular velocity and magnetic field adaptation are able to work together).</p> <p>returns (dict of bool):     Proportional : proportional damping term enabled.     Modified : use modified B-dot (\u03c9 \u00d7 B).     AdaptVelocity : velocity-based adaptive gain.     AdaptMagnetic : magnetic-field-based adaptive gain.     BangBang : bang-bang control.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.b_dot_parameters","title":"<code>b_dot_parameters</code>  <code>property</code>","text":"<p>B-dot control parameters.</p> <p>returns (dict):      Gain (float): The gain factor for the b-dot control law. Applied in the         standard B-dot control law and is the base for adaptive versions.     ProportionalGain (float): Proportional gain for the B-dot control law.         Determines how much the magnetic dipole moment is adjusted based on the         angular velocity.     AngularVelocityRef (float): Reference angular velocity for the         adaptive B-dot control law in deg/s. Is the assumed value when the         algorithm should switch from fast detumbling to more control.     Alpha (float): Exponent for the angular velocity adaptation.     MagneticFieldRef (int): Reference magnetic field for the adaptive B-dot     control law in nT. Is the assumed value somewhere about the average         magnetic field on the low Earth orbit.     Beta (float): Exponent for the magnetic field adaptation.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.date_time","title":"<code>date_time</code>  <code>property</code>","text":"<p>Date and time of the simulation start.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: Current time if \"Now\" is true, otherwise parsed from JSON fields.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.ekf","title":"<code>ekf</code>  <code>property</code>","text":"<p>EKF parameters.</p> <p>returns (dict):     AttitudeNoise (np.ndarray): attitude noise in degrees.     Covariance (float): covariance value.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.euler_angles","title":"<code>euler_angles</code>  <code>property</code>","text":"<p>Initial Euler angles phi, theta, psi. The standard aerospace convention X-Y-Z (known as roll-pitch-yaw) is used, where the first rotation is around the X-axis (roll), the second rotation is around the Y-axis (pitch), and the third rotation is around the Z-axis (yaw).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>ndarray</code> <p>phi -180 to 180 degrees.</p> <code>float</code> <code>ndarray</code> <p>theta -180 to 180 degrees.</p> <code>float</code> <code>ndarray</code> <p>psi -180 to 180 degrees.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.gyroscope","title":"<code>gyroscope</code>  <code>property</code>","text":"<p>Gyroscope settings.</p> <p>returns (dict):     Bias (np.ndarray): bias (deg/s).     ProcessNoise (np.ndarray): process noise (deg/s).</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.iterations_info","title":"<code>iterations_info</code>  <code>property</code>","text":"<p>Simulation time parameters in seconds.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>start time</p> <code>int</code> <code>int</code> <p>end time</p> <code>int</code> <code>int</code> <p>time step</p> <code>int</code> <code>int</code> <p>logging interval</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.magnetometer","title":"<code>magnetometer</code>  <code>property</code>","text":"<p>Magnetometer settings.</p> <p>returns (dict):     Noise (bool): noise flag.     AbsoluteNoise (float): maximum noise amplitude (nT).</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.magnetorquer_params","title":"<code>magnetorquer_params</code>  <code>property</code>","text":"<p>Magnetorquer parameters, works for every axis of rotation.</p> <p>returns (dict):     Coils (int): number of coils.     CoilArea (float): area of each coil in cm^2.     MaxCurrent (float): maximum current in the torquer.     SafetyFactor (float): current reduction factor.     AlphaCap (float): angular acceleration cap (deg/s^2).</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.mode_management","title":"<code>mode_management</code>  <code>property</code>","text":"<p>Mode management thresholds.</p> <p>returns (dict):     DetumblingOff (float): detumbling off threshold (deg/s).     DetumblingOn (float): detumbling on threshold (deg/s).     PointingOff (float): pointing off error angle (deg).     PointingOn (float): pointing on error angle (deg).     PointingDwellTime (int): pointing dwell time (s).</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.planet_data","title":"<code>planet_data</code>  <code>property</code>","text":"<p>Parameters and constants describing the planet (G, M, R).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>dict[float, float, float]</code> <p>G - gravitational constant in m^3/(kg*s^2).</p> <code>float</code> <code>dict[float, float, float]</code> <p>M - mass of the planet in kg.</p> <code>float</code> <code>dict[float, float, float]</code> <p>R - radius of the planet in m.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.quest","title":"<code>quest</code>  <code>property</code>","text":"<p>QUEST parameters.</p> <p>returns (dict):     Weights (np.ndarray): weights for measurements.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.satellite_params","title":"<code>satellite_params</code>  <code>property</code>","text":"<p>Satellite parameters.</p> <p>returns (dict):     Mass (float): mass of the satellite in kg.     Inertia (np.ndarray): inertia matrix in kg*m^2.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.sensor_fusion_algorithm","title":"<code>sensor_fusion_algorithm</code>  <code>property</code>","text":"<p>Selected sensor fusion algorithm.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>algorithm name.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.sensors_on_time","title":"<code>sensors_on_time</code>  <code>property</code>","text":"<p>Time interval for which the sensors are active. In real life conditions sensors and actuators should not work at the same time.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>on time in seconds.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.sunsensor","title":"<code>sunsensor</code>  <code>property</code>","text":"<p>Sun sensor settings.</p> <p>returns (dict):     Noise (bool): noise flag.     AngularNoise (float): angular noise (deg).</p>"},{"location":"#setup.initial_settings.SimulationSetupReader._check_for_additional_keys_in_section","title":"<code>_check_for_additional_keys_in_section(setup_dict, data_dict)</code>","text":"<p>Checks for additional keys in a section of the setup dictionary that are not defined in the data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>setup_dict</code> <code>dict</code> <p>The raw section dictionary from the setup file.</p> required <code>data_dict</code> <code>dict</code> <p>The current data dictionary.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Updated data dictionary with any additional keys.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader._read_initial_parameters","title":"<code>_read_initial_parameters(setup_file)</code>","text":"<p>Reads the initial parameters from setup/initial_parameters.json file.</p>"},{"location":"#setup.initial_settings.SimulationSetupReader.check_for_unknown_settings","title":"<code>check_for_unknown_settings()</code>","text":"<p>Returns a dict of extra keys beyond the first two levels. Only checks: top-level sections and their immediate child keys. Deeper nesting is not validated here.</p>"},{"location":"#setup.two_line_element","title":"<code>setup.two_line_element</code>","text":""},{"location":"#setup.two_line_element.TwoLineElementReader","title":"<code>TwoLineElementReader(tle_txt)</code>","text":"<p>               Bases: <code>TwoLineElement</code></p> <p>Class for reading two-line elements (TLE) from a file.</p> <p>Initialize TLE reader from file.</p> <p>Parameters:</p> Name Type Description Default <code>tle_txt</code> <code>Path</code> <p>Path to TLE text file.</p> required"},{"location":"#setup.two_line_element.TwoLineElementReader.argument_of_perigee","title":"<code>argument_of_perigee</code>  <code>property</code>","text":"<p>Argument of perigee in degrees. The angle between the ascending node and the point of closest approach to the Earth.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angle from 0 to 360 degrees.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.bstar_drag","title":"<code>bstar_drag</code>  <code>property</code>","text":"<p>BSTAR is a way of modeling satellite aerodynamic drag used in the SGP4 model. The drag term is also known as the radiation pressure coefficient.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>BSTAR drag term slice.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.checksum_line1","title":"<code>checksum_line1</code>  <code>property</code>","text":"<p>Checksum of the first line of the TLE.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum of the first line.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.checksum_line2","title":"<code>checksum_line2</code>  <code>property</code>","text":"<p>Checksum of the second line of the TLE.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum of the second line.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.classification","title":"<code>classification</code>  <code>property</code>","text":"<p>Classification of the satellite (e.g., \"U\" for unclassified).</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Classification of the satellite.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.eccentricity","title":"<code>eccentricity</code>  <code>property</code>","text":"<p>Eccentricity of the satellite orbit. A measure of how much the orbit deviates from a perfect circle. A value of 0 indicates a circular orbit, while values close to 1 indicate an elongated orbit.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentricity value between 0 and 1.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.element_number","title":"<code>element_number</code>  <code>property</code>","text":"<p>Element set number of the TLE.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>3-digit number.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.ephemeris_type","title":"<code>ephemeris_type</code>  <code>property</code>","text":"<p>Ephemeris type of the TLE.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Usually 0.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.epoch_day","title":"<code>epoch_day</code>  <code>property</code>","text":"<p>Epoch day of the TLE, representing the time at which the orbital elements are valid given as the day of the year.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Day of the year.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.epoch_year","title":"<code>epoch_year</code>  <code>property</code>","text":"<p>Epoch year of the TLE, representing the time at which the orbital elements are valid given as the year.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Two last digits of the year. May skip the first 0.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.inclination","title":"<code>inclination</code>  <code>property</code>","text":"<p>Inclination of the satellite orbit in degrees. Angle between the orbital plane and the reference plane.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Positive value in degrees.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.launch_number","title":"<code>launch_number</code>  <code>property</code>","text":"<p>Launch number of the satellite in the given year.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>3-digit launch number of the satellite.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.launch_year","title":"<code>launch_year</code>  <code>property</code>","text":"<p>Launch year of the satellite.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Two last digits of the launch year.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.line_1","title":"<code>line_1</code>  <code>property</code>","text":"<p>First line of the TLE.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>First line of the TLE.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.line_2","title":"<code>line_2</code>  <code>property</code>","text":"<p>Second line of the TLE.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Second line of the TLE.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.mean_anomaly","title":"<code>mean_anomaly</code>  <code>property</code>","text":"<p>Mean anomaly in degrees. The angle between the perigee and the current position of the satellite.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angle from 0 to 360 degrees.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.mean_motion","title":"<code>mean_motion</code>  <code>property</code>","text":"<p>Mean motion in revolutions per day. The number of orbits the satellite completes in one day.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Number of revolutions per day.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.mean_motion_derivative_1","title":"<code>mean_motion_derivative_1</code>  <code>property</code>","text":"<p>First derivative of the mean motion also known as the ballistic coefficient.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>First derivative of the mean motion.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.mean_motion_derivative_2","title":"<code>mean_motion_derivative_2</code>  <code>property</code>","text":"<p>Second derivative of the mean motion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Second derivative of the mean motion.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.piece_launch","title":"<code>piece_launch</code>  <code>property</code>","text":"<p>Piece of the launch.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>3-digit piece of the launch.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.raan","title":"<code>raan</code>  <code>property</code>","text":"<p>Right Ascension of Ascending Node (RAAN) in degrees. The angle between the reference direction and the ascending node of the orbit.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angle from 0 to 360 degrees.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.revolution_number","title":"<code>revolution_number</code>  <code>property</code>","text":"<p>Revolution number at epoch. The number of orbits the satellite has completed since launch.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Revolution number.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.satellite_name","title":"<code>satellite_name</code>  <code>property</code>","text":"<p>Name of the satellite (Satellite Catalog Number).</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>5-digit number.</p>"},{"location":"#setup.two_line_element.TwoLineElementReader.read_tle","title":"<code>read_tle()</code>","text":"<p>Read the TLE from the file.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>list[str]</code> <p>TLE string.</p>"},{"location":"#spacecraft","title":"Spacecraft","text":"<p>Integrates satellite subsystems (sensors and actuators), exposes high\u2011level state, and performs control and mode management (detumbling or pointing).</p>"},{"location":"#spacecraft.satellite","title":"<code>spacecraft.satellite</code>","text":""},{"location":"#spacecraft.satellite.SatelliteImplementation","title":"<code>SatelliteImplementation(setup, tle, magnetometer=None, sunsensor=None, sensor_fusion=None)</code>","text":"<p>               Bases: <code>Satellite</code></p> <p>Implementation of the Satellite class.</p> <p>Initialize the satellite object to easily obtain parameters that describe an orbital object and its measurements. It takes the simulation setup, two line element as input parameters that define the initial conditions. Sensor objects are also passed to the satellite for for simulation of readings. Different sensors can be used, but at least two are needed for sensor fusion. Typically the magnetometer is the main sensor.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>SimulationSetup</code> <p>Simulation setup object that contains the initial conditions of the simulation, such as angular velocity, Euler angles, satellite parameters, and iterations information.</p> required <code>tle</code> <code>TwoLineElement</code> <p>Two line element object that describes the initial conditions of the satellite's orbit.</p> required <code>magnetometer</code> <code>Magnetometer</code> <p>Magnetometer object for simulating magnetic field measurements. Readings are returned in the SBF (Satellite Body Frame) and ECI (Earth-Centered Inertial)</p> <code>None</code> <code>sunsensor</code> <code>Sunsensor</code> <p>Sunsensor object for simulating solar vector measurements. Readings are returned in the SBF (Satellite Body Frame) and ECI (Earth-Centered Inertial)</p> <code>None</code> <code>sensor_fusion</code> <code>SensorFusion</code> <p>SensorFusion object for performing sensor fusion algorithms such as TRIAD, QUEST, or EKF.</p> <code>None</code> <code>detumbling_threshold</code> <code>float</code> <p>The angular velocity magnitude above which detumbling is applied. Defaults to 3.0 degrees/s.</p> required"},{"location":"#spacecraft.satellite.SatelliteImplementation.altitude","title":"<code>altitude</code>  <code>property</code>","text":"<p>Altitude of the satellite in km calculated for the given simulation time and using WGS84 (World Geodetic System 1984).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude of the satellite in km.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.angular_acceleration","title":"<code>angular_acceleration</code>  <code>property</code>","text":"<p>Get the angular acceleration of the satellite in rad/s^2. Initialized as [0.0, 0.0, 0.0] and updated after detumbling or pointing was launched.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Angular acceleration of the satellite in rad/s^2.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.angular_velocity","title":"<code>angular_velocity</code>  <code>property</code>","text":"<p>Angular velocity of the satellite in degrees/s. According to the aerospace convention, the angular velocity is given in the order wx, wy, wz (roll, pitch, yaw).</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Angular velocity of the satellite in degrees/s.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.euler_angles","title":"<code>euler_angles</code>  <code>property</code>","text":"<p>Euler angles of the satellite in degrees. The angles are used to easily initialize the satellites position and later for debugging and visualization purposes. The angles are in the order of roll, pitch, and yaw (x, y, z) and are in the range of [-180, 180) degrees. They are obtained from the quaternion representation due to its advantages over Euler angles, such as avoiding gimbal lock and providing a more compact representation of rotations.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated Euler angles of the satellite in degrees (roll, pitch and yaw).</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.inertia_matrix","title":"<code>inertia_matrix</code>  <code>property</code>","text":"<p>Inertia matrix of the satellite in kg*m^2.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.iteration","title":"<code>iteration</code>  <code>property</code>","text":"<p>Current iteration of the simulation. Equals the time in seconds from its start.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.latitude","title":"<code>latitude</code>  <code>property</code>","text":"<p>Latitude of the satellite in degrees calculated for the given simulation time and using WGS84 (World Geodetic System 1984).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude of the satellite in degrees.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.linear_velocity","title":"<code>linear_velocity</code>  <code>property</code>","text":"<p>Linear velocity of the satellite obtained using the skyfield library. By default returns GCRS (Geocentric Celestial Reference System) which is an ECI (Earth-Centered Inertial) frame (fixed to the stars) almost similar to J2000 frame. Distance is given in km and calculated for the given simulation time.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: X, Y and Z velocity of the satellite in km/s for current iteration.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.longitude","title":"<code>longitude</code>  <code>property</code>","text":"<p>Longitude of the satellite in degrees calculated for the given simulation time and using WGS84 (World Geodetic System 1984).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude of the satellite in degrees.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.magnetic_field","title":"<code>magnetic_field</code>  <code>property</code>","text":"<p>Get the magnetic field vector at the satellite's position in the SBF and ECI frames. The first simulates the measurement, the second is used for debugging, sensor fusion algorithms etc. Both are in nT (nanoTesla). Adding bias to the SBF vector can be adjusted in the magnetometer object.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Magnetic field vector in the SBF and ECI frames in form of</p> <code>ndarray</code> <p>[[SBFx, SBFy, SBFz], [ECIx, ECIy, ECIz]].</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.mass","title":"<code>mass</code>  <code>property</code>","text":"<p>Mass of the satellite in kg.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.pointing_error_angle","title":"<code>pointing_error_angle</code>  <code>property</code>","text":"<p>Angle (deg) between the selected body axis (PointingAxis) and the target direction vector (Earth or Sun) computed in the body frame. Initialized as 0.0 and updated after pointing was launched.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Pointing error angle in degrees.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.position","title":"<code>position</code>  <code>property</code>","text":"<p>Position of the satellite obtained using the skyfield library. Skyfield returns a geocentric position in GCRS (an inertial frame aligned with ICRF near J2000). Distance is given in km and calculated for the given simulation time. If using raw SGP4/TEME, explicit transforms to ITRF/ECEF are required for geodetic products.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: X, Y and Z position of the satellite in km for current iteration.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.quaternion","title":"<code>quaternion</code>  <code>property</code>","text":"<p>Quaternion of the satellite. This represents the orientation of the satellite in space - the rotation from the reference ECI frame to the satellite's body frame. The quaternion is a 4-element array that contains the vector part and the scalar part (x, y, z, w). The vector part can be interpreted as a rotation axis and the scalar part represents the angle of rotation around that axis.</p> <p>Useful link: https://probablydance.com/2017/08/05/intuitive-quaternions/ https://quaternions.online/</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: a 4-element array in the form of [x, y, z, w].</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.state_vector","title":"<code>state_vector</code>  <code>property</code>","text":"<p>Get the state vector of the satellite. This object contains all the parameters that are stored during the simulation for later analysis.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.sun_vector","title":"<code>sun_vector</code>  <code>property</code>","text":"<p>Get the Sun vector as observed from Earth. The vector is computed in ICRF and rotated to SBF; parallax due to satellite altitude is neglected.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Sun vector in the SBF and ECI frames in form of</p> <code>ndarray</code> <p>[[SBFx, SBFy, SBFz], [ECIx, ECIy, ECIz]].</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.torque","title":"<code>torque</code>  <code>property</code>","text":"<p>Get the torque applied by the magnetorquers in Nm. Initialized as [0.0, 0.0, 0.0] and updated after detumbling or pointing was launched.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Torque applied by the magnetorquers in Nm.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.two_line_element","title":"<code>two_line_element</code>  <code>property</code>","text":"<p>Two-line element set (TLE) of the satellite. Imported from file as object. Allows to access the parameters describing the satellite's orbital parameters such as inclination, right ascension etc.</p> <p>Returns:</p> Name Type Description <code>TwoLineElement</code> <code>TwoLineElement</code> <p>TLE object containing the orbital parameters.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation._update_pointing_error_noact","title":"<code>_update_pointing_error_noact()</code>","text":"<p>Update _pointing_error_angle even when pointing is off.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.apply_detumbling","title":"<code>apply_detumbling()</code>","text":"<p>Detumbling is the process of reducing the angular velocity of the satellite to a safe level after deployment. Here the popular B-dot algorithm is implemented using the magnetorquers. Different adaptations of the algorithm can be selected inside the initial setting json file to adjust the behavior. If no adaptation is selected the basic B-dot is used.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.apply_ekf","title":"<code>apply_ekf(v_b_list, v_i_list, quaternion_prev, timestemp=1.0)</code>","text":"<p>Apply the Extended Kalman Filter (EKF) for attitude estimation of at least two sensors. The method computes the quaternion from inertial to body using the angular velocity, estimated state, specified sensor accuracy and model parameters. Algorithm parameters can be passed while initializing the sensor fusion class. The satellites quaternion is updated based on this computations.</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list[ndarray]</code> <p>list with vectors in body frame.</p> required <code>v_i_list</code> <code>list[ndarray]</code> <p>list with vectors in inertial frame.</p> required <code>quaternion_prev</code> <code>ndarray</code> <p>Previous quaternion estimate.</p> required <code>timestemp</code> <code>float</code> <p>Time step between the previous and current estimate in seconds. Default is 1.0 second.</p> <code>1.0</code>"},{"location":"#spacecraft.satellite.SatelliteImplementation.apply_pointing","title":"<code>apply_pointing()</code>","text":"<p>Apply pointing control to the satellite. This method uses the B-cross algorithm to calculate the required torque to align the satellite's body frame with a target vector in the inertial frame. The target vector can be either the Earth direction or the Sun direction, depending on the selected task in the initial settings.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.apply_quest","title":"<code>apply_quest(v_b_list, v_i_list)</code>","text":"<p>Apply the QUEST algorithm for attitude determination of at least two sensors. This method computes the quaternion from inertial to body frame in a slightly more precise way than TRIAD. Weights can be optionally added while initializing the sensor fusion class. The satellites quaternion is updated based on this computations.</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list[ndarray]</code> <p>list with vectors in body frame.</p> required <code>v_i_list</code> <code>list[ndarray]</code> <p>list with vectors in inertial frame.</p> required"},{"location":"#spacecraft.satellite.SatelliteImplementation.apply_rotation","title":"<code>apply_rotation()</code>","text":"<p>This method updates the satellite's orientation based on the current angular velocity. A new quaternion is assigned. This is a rather theoretical rotation.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.apply_triad","title":"<code>apply_triad(v_b_list, v_i_list)</code>","text":"<p>Apply the TRIAD algorithm for attitude determination of two sensors. This method computes the quaternion from inertial to body frame using two vectors in both frames. The first vector is typically the more accurate. The satellites quaternion is updated based on this computations.</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list[ndarray]</code> <p>list with vectors in body frame.</p> required <code>v_i_list</code> <code>list[ndarray]</code> <p>list with vectors in inertial frame.</p> required"},{"location":"#spacecraft.satellite.SatelliteImplementation.fuse_sensors","title":"<code>fuse_sensors(v_b_list, v_i_list, quaternion_prev=None)</code>","text":"<p>Perform the sensor fusion by applying the algorithm selected in initial settings json file.</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list[ndarray]</code> <p>list with vectors in body frame.</p> required <code>v_i_list</code> <code>list[ndarray]</code> <p>list with vectors in inertial frame.</p> required <code>quaternion_prev</code> <code>ndarray</code> <p>Previous quaternion estimate.</p> <code>None</code>"},{"location":"#spacecraft.satellite.SatelliteImplementation.manage_actuators_sensors_timing","title":"<code>manage_actuators_sensors_timing()</code>","text":"<p>Manage the timing of actuators and sensors operation. Ensures that actuators and sensors do not operate simultaneously.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.manage_modes","title":"<code>manage_modes()</code>","text":"<p>Mode manager for detumbling / pointing / idle. - Starts pointing after detumbling when rate below detumbling_threshold. - Finishes pointing after dwell in low-error, low-rate state (to Idle). - Re-enters detumbling only for very high rates. - Re-enables pointing if error drifts after completion.</p>"},{"location":"#spacecraft.satellite.SatelliteImplementation.update_iteration","title":"<code>update_iteration(iteration)</code>","text":"<p>Update the current iteration of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>int</code> <p>The current iteration of the simulation. Equals the time in seconds from its start.</p> required"},{"location":"#spacecraft.actuator","title":"<code>spacecraft.actuator</code>","text":""},{"location":"#spacecraft.actuator.MagnetorquerImplementation","title":"<code>MagnetorquerImplementation(setup, satellite)</code>","text":"<p>Abstract class for magnetorquer parameters.</p> <p>Initialize the magnetorquer with the satellite and setup parameters.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>SimulationSetup</code> <p>The simulation setup object. Contains magnetorquer</p> required <code>satellite</code> <code>Satellite</code> <p>The satellite object.</p> required <code>safety_factor</code> <code>float</code> <p>A factor to limit the current in the magnetorquer to a safe value.</p> required"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._apply_alpha_cap","title":"<code>_apply_alpha_cap(tau_raw, coriolis)</code>","text":"<p>Enforce optional alpha cap by scaling magnetic torque. alpha = I^{-1}(stau_raw - coriolis) = sa + b, s in [0,1]. Returns (tau_limited, alpha_limited, s).</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._apply_angle_bands","title":"<code>_apply_angle_bands(theta, m_align_base, m_damp_base, pointing_deg_threshold_deg=50.0, mid_deg=15.0, small_angle_damp_multiplier=1.0, mid_damp_fraction=0.3)</code>","text":"<p>Apply angle-band logic and return (m_align, m_damp). Defaults: - theta &gt; pointing_deg_threshold_deg \u2192 pure damping - mid_deg &lt; theta \u2264 pointing_deg_threshold_deg \u2192 alignment + mid damping - theta \u2264 mid_deg \u2192 pure damping (scaled by small_angle_damp_multiplier)</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._apply_high_rate_damp_gate","title":"<code>_apply_high_rate_damp_gate(omega_norm, on_deg=0.3, off_deg=0.2)</code>","text":"<p>Force damp-only when |\u03c9| &gt; on_deg [deg/s] until it falls below off_deg. Returns current gate state.</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._apply_poor_geometry_gate","title":"<code>_apply_poor_geometry_gate(sin_gamma, on=0.25, off=0.35)</code>","text":"<p>Gate when target ~ parallel to B (sin_gamma small). on: enter when sin_gamma &lt; on; off: exit when sin_gamma &gt; off.</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._b_decompose","title":"<code>_b_decompose(magnetic_field_sb, angular_velocity_rad_s)</code>","text":"<p>B-field quantities and \u03c9 decomposition. Returns (b, b_norm, b_hat, inv_b2, omega_par, omega_perp).</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._compute_error_vec_and_theta","title":"<code>_compute_error_vec_and_theta(align_axis, target_dir_body)</code>","text":"<p>Rotation vector (rad) to rotate align_axis into target_dir_body. Returns (error_vec [rad], theta [rad]). Includes small deadzone.</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._omega_trend_scale","title":"<code>_omega_trend_scale(omega_norm, gated, deadband_deg=0.001, scale_inc=0.4, scale_dec=1.8)</code>","text":"<p>Scale dipole based on |\u03c9| trend: - if increasing by &gt; deadband \u2192 scale_inc - if decreasing by &gt; deadband \u2192 scale_dec Disabled while 'gated' is True (state still updated).</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation._shape_dipole","title":"<code>_shape_dipole(m_cmd, dt)</code>","text":"<p>First-order low-pass toward m_cmd and vector slew limit. Set self._m_tau=0 and self._m_slew=0 to bypass.</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation.apply_torquer_with_saturation","title":"<code>apply_torquer_with_saturation(magnetic_dipole_moment)</code>","text":"<p>Uniform-scaling saturation. Converts dipole (A\u00b7m^2) to per-axis current (A) and scales the whole vector so no axis exceeds its limit. The maximum current, coil area, and number of turns are predefined torquer parameters.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_dipole_moment</code> <code>ndarray</code> <p>The theoretical magnetic dipole moment vector in A\u00b7m^2.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The saturated current per axis in A.</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation.b_cross","title":"<code>b_cross(magnetic_field_sbf, align_axis, target_dir_body)</code>","text":"<p>B-cross pointing control (Earth or Sun pointing). Generates angular acceleration (rad/s^2) based on the error angle. The method combines alignment and damping torques to achieve stable pointing.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field_sbf</code> <code>ndarray</code> <p>The magnetic field vector in the spacecraft body frame in nT.</p> required <code>align_axis</code> <code>ndarray | list</code> <p>The axis in the body frame to be aligned with the target direction. Specified inside the initial settings json file.</p> required <code>target_dir_body</code> <code>ndarray</code> <p>The target direction vector in the body frame. Calculated based on the specified mode (\"earth_pointing\" or \"sun_pointing\").</p> required"},{"location":"#spacecraft.actuator.MagnetorquerImplementation.b_dot","title":"<code>b_dot(magnetic_field, sensing_time, adapt_magnetic=False, adapt_angular=False, proportional=False, modified=False)</code>","text":"<p>Perform detumbling using the magnetorquer and standard B-dot algorithm. This method calculates the required magnetic dipole moment (essentially the magnetic field of the magnetorquer) to generate opposing torque and reduce the angular velocity of the satellite. The assumption in this code are three orthogonal coils, each with the same area and number of turns.</p> <p>Useful link: https://www.uio.no/studier/emner/matnat/fys/FYS3240/v23/lectures/l11---control-systems-v23.pdf https://www.aero.iitb.ac.in/satelliteWiki/index.php/B_Dot_Law</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray</code> <p>The current magnetic field vector in nT.</p> required <code>sensing_time</code> <code>float</code> <p>Sensor on time used to get the mean derivative from the magnetic field measurements.</p> required <code>adapt_magnetic</code> <code>bool</code> <p>Whether to adapt the gain based on the magnetic field strength.</p> <code>False</code> <code>adapt_angular</code> <code>bool</code> <p>Whether to adapt the gain based on the angular velocity to include damping.</p> <code>False</code> <code>proportional</code> <code>bool</code> <p>Whether to include a proportional term based on the angular velocity.</p> <code>False</code> <code>modified</code> <code>bool</code> <p>Whether to use the modified B-dot control law that is based directly on the angular velocity (gyroscopes) and magnetic field measurements, instead of magnetic field rate of change.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The angular acceleration vector to be applied to the satellite.</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation.coils_to_dipole","title":"<code>coils_to_dipole(current_per_axis)</code>","text":"<p>Convert coil currents [A] to magnetic dipole [A\u00b7m\u00b2].</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation.current_to_angular_acceleration","title":"<code>current_to_angular_acceleration(commanded_dipol, magnetic_field, current_per_axis)</code>","text":"<p>Convert a given magnetic dipole moment to torque and then angular acceleration. If alpha_cap is set, scale torque/current so ||alpha|| &lt;= cap.</p> <p>Parameters:</p> Name Type Description Default <code>commanded_dipol</code> <code>ndarray</code> <p>The commanded magnetic dipole moment in A\u00b7m\u00b2.</p> required <code>magnetic_field</code> <code>ndarray</code> <p>The magnetic field vector in T.</p> required <code>current_per_axis</code> <code>ndarray</code> <p>The saturated current per axis in A.</p> required <p>Returns:     (np.ndarray, np.ndarray):         angular acceleration [rad/s\u00b2], current_per_axis [A].</p>"},{"location":"#spacecraft.actuator.MagnetorquerImplementation.filtered_derivative","title":"<code>filtered_derivative(magnetic_field, sensing_time, alpha=0.7)</code>","text":"<p>Calculate the filtered derivative of the magnetic field.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray</code> <p>The current magnetic field vector.</p> required <code>sensing_time</code> <code>float</code> <p>Sensor on time used to get the mean derivative from the magnetic field measurements.</p> required <code>alpha</code> <code>float</code> <p>The filter coefficient.</p> <code>0.7</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The filtered derivative of the magnetic field.</p>"},{"location":"#spacecraft.sensors","title":"<code>spacecraft.sensors</code>","text":""},{"location":"#spacecraft.sensors.MagnetometerImplementation","title":"<code>MagnetometerImplementation(setup)</code>","text":"<p>Initialize the Magnetometer class. It is responsible for calculating the Earth's magnetic field vector at a given satellite position and time using the International Geomagnetic Reference Field (IGRF) model. The measurement is simulated in the X, Y, Z axes by transforming it to the Satellite Body Frame (SBF) and optionally adding noise. Noise parameters are specified in the initial settings json file.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>SimulationSetup</code> <p>The simulation setup containing the magnetometer noise parameters.</p> required"},{"location":"#spacecraft.sensors.MagnetometerImplementation.get_magnetic_field","title":"<code>get_magnetic_field(satellite, julian_date)</code>","text":"<p>Get the magnetic field vector at the satellite's position and given time. Magnetic field model is taken from the IGRF via pyIGRF library. Originally it is in NED (North-East-Down) frame and in nT (nanoTesla) thus a transformation is needed to convert it to ECEF and then to ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>Satellite</code> <p>The satellite object containing the TLE data and current status.</p> required <code>julian_date</code> <code>Time</code> <p>Julian date for which the magnetic field vector is to be computed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Magnetic field vector in NED frame in nT (nanoTesla).</p>"},{"location":"#spacecraft.sensors.MagnetometerImplementation.simulate_magnetometer","title":"<code>simulate_magnetometer(satellite, julian_date)</code>","text":"<p>Simulate the magnetometer readings. This method computes the magnetic field vector at a given position and date, optionally adds noise and transforms it to the Satellite Body Frame (SBF) and Earth Centered Inertial Frame (ECI). Returned in nT (nanoTesla).</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>Satellite</code> <p>The satellite object containing the TLE data and current status.</p> required <code>julian_date</code> <code>Time</code> <p>Julian date for which the magnetic field vector is to be computed.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>tuple[np.ndarray, np.ndarray]: Simulated magnetic field vectors in the Satellite Body Frame (SBF) and Earth-Centered Inertial (ECI) frame. Returned in nT (nanoTesla). The first three elements are in the SBF frame, and the next three are in the ECI frame.</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation","title":"<code>SensorFusionImplementation(setup, algorithm, init_quaternion)</code>","text":"<p>Initialize the SensorFusion class. Sensor fusion combines data that comes from multiple sensors to estimate a more accurate state of the system. In this case of attitude determination it applies to the quaternion. Often the order in which the parameters are given is relevant (depending on the expected accuracy) also estimations about noise bias can be passed while initializing.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>SimulationSetup</code> <p>The simulation setup containing the sensor fusion parameters such as weights, gyro bias, noise, and covariance.</p> required <code>algorithm</code> <code>str</code> <p>List of algorithms to initialize for the sensor fusion. Supported algorithms: 'triad', 'quest', 'ekf'.</p> required <code>init_quaternion</code> <code>ndarray</code> <p>Initial quaternion [x, y, z, w] for the attitude.</p> required"},{"location":"#spacecraft.sensors.SensorFusionImplementation._align_quaternion_sign","title":"<code>_align_quaternion_sign(algorithm, quaternion)</code>","text":"<p>Flip quaternion sign if needed to keep continuity with the last saved one.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>str</code> <p>The algorithm used for sensor fusion.</p> required <code>quaternion</code> <code>ndarray</code> <p>The computed quaternion.</p> required"},{"location":"#spacecraft.sensors.SensorFusionImplementation._init_measurement_noise","title":"<code>_init_measurement_noise(setup)</code>","text":"<p>Initialize EKF measurement noise standard deviations from sensor settings. magnetometer: component noise (nT) uniform in [-a/2, a/2] \u2192 \u03c3 = a/\u221a12,               then normalized by |B| reference (dimensionless for unit vector). sunsensor: angular noise (deg) uniform \u2192 \u03c3 = (deg\u2192rad)/\u221a12.</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation.build_triad","title":"<code>build_triad(v1, v2)</code>","text":"<p>Build an orthogonal triad frame from two vectors (set of three perpendicular vectors). The first vector is the primary axis, the second vector is calculated as the cross product of the first vector and the second vector, and the third vector is the cross product of the first and second vectors. This creates a right-handed coordinate system which can be represented as a 3x3 rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>v1</code> <code>ndarray</code> <p>First vector.</p> required <code>v2</code> <code>ndarray</code> <p>Second vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 3x3 rotation matrix representing the TRIAD frame.</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation.ekf","title":"<code>ekf(v_b_list, v_i_list, angular_velocity, timestep, quaternion)</code>","text":"<p>Extended Kalman Filter (EKF) for attitude estimation based on gyroscope measurements and at least two vector measurements. It is a recursive algorithm (updates over time) that combines the gyroscope data (angular velocity) with the vector measurements (magnetic field and sun vector). The algorithm consists of two steps: prediction and update. The prediction is based on angular velocity, while the update incorporates the vector measurements. Compared to QUEST, EKF can handle noisy measurements and biases giving a comprehensive and accurate estimate.</p> <p>Useful links: https://medium.com/@sasha_przybylski/the-math-behind-extended-kalman-filtering-0df981a87453 https://automaticaddison.com/extended-kalman-filter-ekf-with-python-code-example/</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list of np.ndarray</code> <p>Body frame unit vectors.</p> required <code>v_i_list</code> <code>list of np.ndarray</code> <p>Inertial frame unit vectors.</p> required <code>dt</code> <code>float</code> <p>Time step for the EKF update.</p> required <code>quaternion</code> <code>ndarray</code> <p>Current attitude quaternion [x, y, z, w].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated quaternion estimate [x, y, z, w].</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation.prediction_step","title":"<code>prediction_step(angular_velocity, quaternion, timestep)</code>","text":"<p>Predict step of the EKF using gyroscope data. The state (quaternion) is just rotated by the angular velocity in a given time step giving the predicted attitude. The gyroscope bias is also corrected in this step propagating the corrected covariance matrix.</p> <p>Parameters:</p> Name Type Description Default <code>angular_velocity</code> <code>ndarray</code> <p>Angular velocity measurement [rad/s]</p> required <code>quaternion</code> <code>ndarray</code> <p>Current attitude quaternion [x, y, z, w]</p> required <code>timestep</code> <code>float</code> <p>Time increment [s]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated quaternion estimate [x, y, z, w].</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation.quest","title":"<code>quest(v_b_list, v_i_list)</code>","text":"<p>QUEST (QUaternion ESTimator) algorithm for optimal attitude estimation of at least two sensors. The algorithm solves the Wahba problem by finding the solution (rotation matrix) that minimizes the error between a set of weighted vectors in the body frame and their corresponding vectors in the inertial frame. It can take more measurements than TRIAD, and it is more robust to noise and outliers giving a more accurate estimate.</p> <p>Useful links: https://www.aero.iitb.ac.in/satelliteWiki/index.php/QuEST https://en.wikipedia.org/wiki/Wahba%27s_problem</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list of np.ndarray</code> <p>Body frame vectors.</p> required <code>v_i_list</code> <code>list of np.ndarray</code> <p>Inertial frame vectors.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Quaternion [x, y, z, w] estimating attitude (ECI to body).</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation.save_to_data_dict","title":"<code>save_to_data_dict(algorithm, data)</code>","text":"<p>Save the computed quaternion to the data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>algorithm</code> <code>str</code> <p>The algorithm used for sensor fusion.</p> required <code>data</code> <code>ndarray</code> <p>The computed quaternion.</p> required"},{"location":"#spacecraft.sensors.SensorFusionImplementation.triad","title":"<code>triad(v_b_list, v_i_list)</code>","text":"<p>TRIAD  (Three-Axis Attitude Determination) algorithm for attitude determination of two sensors. It is a basic and simple algorithm used in aerospace. This method computes a rotation matrix from inertial to body frame using two vectors in both frames (SBF, ECI). The resulting rotation is a relative transformation between two orthogonal triads (coordinate systems created based on the given vectors) that represent different frames. The first vector is typically the more accurate measurement.</p> <p>Useful links: https://www.aero.iitb.ac.in/satelliteWiki/index.php/Triad_Algorithm</p> <p>Parameters:</p> Name Type Description Default <code>v_b_list</code> <code>list of np.ndarray</code> <p>Body frame vectors.</p> required <code>v_i_list</code> <code>list of np.ndarray</code> <p>Inertial frame vectors.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: quaternion representing the rotation from inertial to body frame.</p>"},{"location":"#spacecraft.sensors.SensorFusionImplementation.update_step","title":"<code>update_step(measurement_vector, reference_vector, quaternion, measurement_noise)</code>","text":"<p>Update step of the EKF using vector measurements. The measurement is compared to the predicted measurement (rotated reference vector), then Kalman Gain is calculated based on the measurement Jacobian and the covariance matrix. Kalman Gain tells how much to trust the measurement compared to the prediction. Gyro bias and covariance are also adjusted. Lastly the quaternion is computed.</p> <p>Parameters:</p> Name Type Description Default <code>measurement_vector</code> <code>ndarray</code> <p>Measurement vector [x, y, z]</p> required <code>reference_vector</code> <code>ndarray</code> <p>Reference vector [x, y, z]</p> required <code>quaternion</code> <code>ndarray</code> <p>Current attitude quaternion [x, y, z, w]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated attitude quaternion [x, y, z, w]</p>"},{"location":"#spacecraft.sensors.SunsensorImplementation","title":"<code>SunsensorImplementation(setup)</code>","text":"<p>Initialize the Sunsensor class. It is responsible for calculating the direction of the Sun as it would be observed from the satellite. Due to the large distance the altitude is neglected and the vector is approximated as the observation from Earth. Optional noise can be applied. By default the sunsensor is assumed a bit less accurate than the magnetometer.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>SimulationSetup</code> <p>The simulation setup containing the sunsensor noise parameters.</p> required"},{"location":"#spacecraft.sensors.SunsensorImplementation.simulate_sunsensor","title":"<code>simulate_sunsensor(satellite, julian_date)</code>","text":"<p>Simulate the Sun sensor readings. This method computes the Sun vector at a given satellite position and date, optionally adds noise and transforms it to the Satellite Body Frame (SBF).</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>object</code> <p>The satellite object containing the TLE data and current status.</p> required <code>julian_date</code> <code>Time</code> <p>Julian date for which the Sun vector is to be computed.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Simulated Sun vector in the Satellite Body Frame (SBF).</p>"},{"location":"#spacecraft.sensors.SunsensorImplementation.sun_vector_eci","title":"<code>sun_vector_eci(julian_date)</code>","text":"<p>Compute Sun's position in ICRF using Skyfield as seen from Earth (ECI).</p> <p>Parameters:</p> Name Type Description Default <code>julian_date</code> <code>Time</code> <p>Julian date for which to compute the Sun's position.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: [x, y, z] in kilometers in ICRF (ECI) frame</p>"},{"location":"#core","title":"Core","text":"<p>Provides foundational utilities: math helpers, coordinate and frame transformations, logging, and state vector management.</p>"},{"location":"#core.state","title":"<code>core.state</code>","text":""},{"location":"#core.state.State","title":"<code>State()</code>","text":""},{"location":"#core.state.State.next_row","title":"<code>next_row()</code>","text":"<p>Start a new row; pre-fill all existing columns with NaN.</p>"},{"location":"#core.state.State.reset","title":"<code>reset()</code>","text":"<p>Clear all columns and row count.</p>"},{"location":"#core.transformations","title":"<code>core.transformations</code>","text":""},{"location":"#core.transformations.earth_direction_body","title":"<code>earth_direction_body(position_eci, quat_sb_from_eci)</code>","text":"<p>Return unit vector in body frame pointing toward Earth's center (nadir).</p> <p>Parameters:</p> Name Type Description Default <code>position_eci</code> <code>ndarray</code> <p>Satellite position in ECI frame.</p> required <code>quat_sb_from_eci</code> <code>ndarray</code> <p>Quaternion rotating ECI -&gt; body [x, y, z, w].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Unit Earth direction in body frame.</p>"},{"location":"#core.transformations.ecef_to_eci","title":"<code>ecef_to_eci(ecef_vec, time)</code>","text":"<p>Convert a vector from ECEF (Earth-Centered, Earth-Fixed) to ECI (Earth-Centered Inertial) frame using Greenwich apparent sidereal time.</p> Note <p>This is a simplified rotation about Z by GAST. For precise ITRF\u2194GCRS transformations consider full precession\u2013nutation and EOP models.</p> <p>Parameters:</p> Name Type Description Default <code>ecef_vec</code> <code>ndarray</code> <p>Vector in ECEF frame.</p> required <code>time</code> <code>timelib</code> <p>Skyfield Time object (UTC or TT).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Vector in ECI/GCRS-like frame.</p>"},{"location":"#core.transformations.eci_to_sbf","title":"<code>eci_to_sbf(vec_eci, quat_sb_from_eci)</code>","text":"<p>Transform a vector from the ECI (Earth-Centered Inertial) frame to the SBF (Satellite Body Frame) using a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>vec_eci</code> <code>ndarray</code> <p>Vector in ECI frame.</p> required <code>quat_sb_from_eci</code> <code>ndarray</code> <p>Quaternion representing rotation from ECI to satellite body frame, in [x, y, z, w] format.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Vector in satellite body frame.</p>"},{"location":"#core.transformations.enu_to_ecef","title":"<code>enu_to_ecef(enu_vec, lat_deg, lon_deg)</code>","text":"<p>Convert a vector from ENU (East-North-Up) to ECEF (Earth-Centered, Earth-Fixed).</p> <p>Parameters:</p> Name Type Description Default <code>enu_vec</code> <code>ndarray</code> <p>Vector in ENU frame.</p> required <code>lat_deg</code> <code>float</code> <p>Latitude in degrees.</p> required <code>lon_deg</code> <code>float</code> <p>Longitude in degrees.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Vector in ECEF frame.</p>"},{"location":"#core.transformations.euler_xyz_to_quaternion","title":"<code>euler_xyz_to_quaternion(euler_angles, degrees=True)</code>","text":"<p>Convert Euler angles in X-Y-Z convention to a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>euler_angles</code> <code>ndarray</code> <p>Euler angles [x1, y1, z1] in degrees or radians.</p> required <code>degrees</code> <code>bool</code> <p>If True, input angles are in degrees. If False, in radians.</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Quaternion as [x, y, z, w].</p>"},{"location":"#core.transformations.ned_to_ecef","title":"<code>ned_to_ecef(ned_vec, lat_deg, lon_deg)</code>","text":"<p>Convert a vector from NED (North, East, Down) to ECEF using ENU as an intermediate.</p> <p>Parameters:</p> Name Type Description Default <code>ned_vec</code> <code>ndarray</code> <p>Vector in NED frame.</p> required <code>lat_deg</code> <code>float</code> <p>Latitude in degrees.</p> required <code>lon_deg</code> <code>float</code> <p>Longitude in degrees.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Vector in ECEF frame.</p>"},{"location":"#core.transformations.quat_deriv","title":"<code>quat_deriv(quaternion, angular_velocity)</code>","text":"<p>Compute the quaternion time derivative given angular velocity.</p> <p>Parameters:</p> Name Type Description Default <code>quaternion</code> <code>ndarray</code> <p>Quaternion [x, y, z, w], should be normalized.</p> required <code>angular_velocity</code> <code>ndarray</code> <p>Angular velocity [wx, wy, wz] in rad/s (body frame).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Quaternion derivative [x_dot, y_dot, z_dot, w_dot]</p>"},{"location":"#core.transformations.quat_multiply","title":"<code>quat_multiply(q1, q2)</code>","text":"<p>Hamilton product of two quaternions [x, y, z, w].</p> <p>Parameters:</p> Name Type Description Default <code>q1</code> <code>ndarray</code> <p>First quaternion [x1, y1, z1, w1].</p> required <code>q2</code> <code>ndarray</code> <p>Second quaternion [x2, y2, z2, w2].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Resulting quaternion [x, y, z, w].</p>"},{"location":"#core.transformations.quaternion_to_euler_xyz","title":"<code>quaternion_to_euler_xyz(quat, degrees=True)</code>","text":"<p>Convert a quaternion to Euler angles in X-Y-Z convention (degrees).</p> <p>Parameters:</p> Name Type Description Default <code>quat</code> <code>ndarray</code> <p>Quaternion in [x, y, z, w] format.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Euler angles [x1, y1, z1] in degrees.</p>"},{"location":"#core.transformations.rotate_vector_by_quaternion","title":"<code>rotate_vector_by_quaternion(vector, quaternion)</code>","text":"<p>Rotate a vector by a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>Vector to be rotated.</p> required <code>quaternion</code> <code>ndarray</code> <p>Quaternion in [x, y, z, w] format.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Rotated vector.</p>"},{"location":"#core.transformations.rotation_matrix_to_quaternion","title":"<code>rotation_matrix_to_quaternion(rotation_matrix)</code>","text":"<p>Convert a rotation matrix to a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_matrix</code> <code>ndarray</code> <p>3x3 rotation matrix.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Quaternion in [x, y, z, w] format.</p>"},{"location":"#core.transformations.sbf_to_eci","title":"<code>sbf_to_eci(vec_sbf, quat_sb_from_eci)</code>","text":"<p>Transform a vector from the SBF (Satellite Body Frame) to the ECI (Earth-Centered Inertial) frame using a quaternion. The rotation from SBF to ECI is the inverse of the rotation from ECI to SBF.</p> <p>Parameters:</p> Name Type Description Default <code>vec_sbf</code> <code>ndarray</code> <p>Vector in SBF frame.</p> required <code>quat_sb_from_eci</code> <code>ndarray</code> <p>Quaternion representing rotation from ECI to satellite body frame, in [x, y, z, w] format.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Vector in ECI frame.</p>"},{"location":"#core.transformations.sun_direction_body","title":"<code>sun_direction_body(sun_vector_eci, quat_sb_from_eci)</code>","text":"<p>Return unit vector in body frame pointing toward the Sun. sun_vector_eci: Sun direction (or position difference) in ICRF/ECI frame                 (only direction is used; it will be normalized). quat_sb_from_eci: Quaternion rotating ECI -&gt; body [x, y, z, w].</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Unit Sun direction in body frame.</p>"},{"location":"#core.transformations.update_quaternion_by_angular_velocity","title":"<code>update_quaternion_by_angular_velocity(quaternion, angular_velocity, dt=1.0)</code>","text":"<p>Update the quaternion based on the angular velocity and time step.</p> <p>Parameters:</p> Name Type Description Default <code>quaternion</code> <code>ndarray</code> <p>Current quaternion in [x, y, z, w] format.</p> required <code>angular_velocity</code> <code>ndarray</code> <p>Angular velocity in radians/s.</p> required <code>dt</code> <code>float</code> <p>Time step in seconds.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Updated quaternion in [x, y, z, w] format.</p>"},{"location":"#core.transformations.vector_angular_noise","title":"<code>vector_angular_noise(vec, angle_deg)</code>","text":"<p>Rotate the unit vector by a random axis with angular noise.</p> <p>Parameters:</p> Name Type Description Default <code>vec</code> <code>ndarray</code> <p>The input unit vector to be rotated.</p> required <code>angle_deg</code> <code>float</code> <p>The angular noise in degrees.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The rotated vector.</p>"},{"location":"#core.utilities","title":"<code>core.utilities</code>","text":""},{"location":"#core.utilities.basic_state_vector","title":"<code>basic_state_vector(satellite)</code>","text":"<p>Add the most important parameters to the state vector.</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>Satellite</code> <p>The satellite object containing the TLE data and current status.</p> required"},{"location":"#core.utilities.calculate_pointing_error","title":"<code>calculate_pointing_error(target_vector, current_vector)</code>","text":"<p>Calculate the pointing error angle between two vectors in degrees.</p> <p>Parameters:</p> Name Type Description Default <code>target_vector</code> <code>ndarray</code> <p>Target direction vector.</p> required <code>current_vector</code> <code>ndarray</code> <p>Current direction vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pointing error angle in degrees.</p>"},{"location":"#core.utilities.degrees_to_rad","title":"<code>degrees_to_rad(values)</code>","text":"<p>Convert a list or numpy array of floats from degrees to radians.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list or ndarray</code> <p>Iterable of floats in degrees.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of floats in radians.</p>"},{"location":"#core.utilities.filter_decimal_places","title":"<code>filter_decimal_places(array, decimal_places)</code>","text":"<p>Round each element to specified number of decimal places</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Input numpy array or list</p> required <code>decimal_places</code> <code>int</code> <p>Number of decimal places to keep</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Filtered array with specified precision</p>"},{"location":"#core.utilities.filter_significant_digits","title":"<code>filter_significant_digits(array, sig_digits)</code>","text":"<p>Filter the array to have a specified number of significant digits.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>Input array of floats.</p> required <code>sig_digits</code> <code>int</code> <p>Number of significant digits to retain.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array with values formatted to the specified significant digits.</p>"},{"location":"#core.utilities.get_lla","title":"<code>get_lla(satellite)</code>","text":"<p>Get the latitude, longitude and altitude of the satellite.</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>Satellite</code> <p>The satellite object containing the TLE data and current status.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple</code> <p>latitude, longitude and altitude of the satellite.</p>"},{"location":"#core.utilities.limit_norm","title":"<code>limit_norm(vector, cap, eps=1e-12)</code>","text":"<p>Uniformly scale 'vector' so that its L2 norm &lt;= cap. - Returns zeros if cap &lt;= 0 or cap is not finite. - Handles lists/tuples/ndarray. - Copies output to avoid aliasing the input.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>ndarray</code> <p>Input vector.</p> required <code>cap</code> <code>float</code> <p>Maximum allowed norm.</p> required <code>eps</code> <code>float</code> <p>Small value to prevent division by zero.</p> <code>1e-12</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Vector with limited norm.</p>"},{"location":"#core.utilities.log_init_state","title":"<code>log_init_state(setup)</code>","text":"<p>Log initial simulation state.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <p>Simulation setup object.</p> required"},{"location":"#core.utilities.normalize","title":"<code>normalize(v)</code>","text":"<p>Normalize a vector to unit length. Args:     v (np.ndarray): Input vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Normalized vector.</p>"},{"location":"#core.utilities.rad_to_degrees","title":"<code>rad_to_degrees(values)</code>","text":"<p>Convert a list or numpy array of floats from radians to degrees.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list or ndarray</code> <p>Iterable of floats in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of floats in degrees.</p>"},{"location":"#core.utilities.skew_symmetric","title":"<code>skew_symmetric(v)</code>","text":"<p>Compute the skew-symmetric matrix of a 3D vector.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>Input vector.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Skew-symmetric matrix.</p>"},{"location":"#core.utilities.time_julian_date","title":"<code>time_julian_date(satellite)</code>","text":"<p>Convert the current epoch to Julian Date. Current date is the epoch of the TLE plus the number of seconds from simulation start as a fraction of a day. The Julian Date is a continuous count of days since the beginning of the Julian Period on January 1, 4713 BC at noon. It is used in astronomy and other fields to provide a uniform time scale for calculations.</p> <p>Parameters:</p> Name Type Description Default <code>satellite</code> <code>Satellite</code> <p>The satellite object containing the TLE data.</p> required <p>Returns:</p> Type Description <code>Time</code> <p>skyfield.Time: The Julian Date corresponding to the current epoch.</p>"},{"location":"#visualizations","title":"Visualizations","text":"<p>Generates plots (matplotlib for static figures, plotly for interactive and live charts). Enables quick inspection of simulation progress.</p>"},{"location":"#visualizations.visualizations","title":"<code>visualizations.visualizations</code>","text":""},{"location":"#visualizations.visualizations.LivePlotlyLine","title":"<code>LivePlotlyLine(labels, title, xlabel, ylabel, window=None, max_points=10000, output_dir=None)</code>","text":"<p>Real-time line plotting with Plotly FigureWidget. Call update(t, ys) inside your loop; display appears automatically in notebooks.</p> <p>Initialize a live-updating FigureWidget with multiple series.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>list[str]</code> <p>Names for each Y-series line.</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>ylabel</code> <code>str</code> <p>Y axis label.</p> required <code>window</code> <code>float | None</code> <p>Optional rolling window width in X units; if set, only the last window of data is displayed.</p> <code>None</code> <code>max_points</code> <code>int</code> <p>Hard cap on stored points per series (for memory bound).</p> <code>10000</code> <code>output_dir</code> <code>Path | None</code> <p>Directory where finish() writes the HTML file.</p> <code>None</code>"},{"location":"#visualizations.visualizations.LivePlotlyLine.finish","title":"<code>finish(filename=None)</code>","text":"<p>Save the current live plot to an HTML file (if a filename is provided).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | None</code> <p>Base filename (without extension). When None, nothing is saved.</p> <code>None</code>"},{"location":"#visualizations.visualizations.LivePlotlyLine.update","title":"<code>update(t, ys)</code>","text":"<p>Append a new sample and redraw the visible data window.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>New X value (e.g., time in seconds).</p> required <code>ys</code> <code>list[float] | tuple[float, ...]</code> <p>Iterable of Y values, one per series defined at construction.</p> required"},{"location":"#visualizations.visualizations.MatplotlibPlots","title":"<code>MatplotlibPlots(output_dir=Path(__file__).resolve().parent, save=True, show=False)</code>","text":"<p>This class handles the creation of plots using matplotlib library. Main parameters may be adjusted in PlotConfig dataclass.</p> Typical usage <p>mpl = MatplotlibPlots(save=True, show=False) mpl.line_plot({\"Sine\": (x, y)}, \"Sine\", \"t\", \"sin(t)\", \"sine_plot\")</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path</code> <p>Path where the output plots will be saved. Defaults to the directory of the current file.</p> <code>parent</code> <code>save</code> <code>bool</code> <p>Whether to save the plots. Defaults to True.</p> <code>True</code> <code>show</code> <code>bool</code> <p>Whether to display the plots. Defaults to False.</p> <code>False</code>"},{"location":"#visualizations.visualizations.MatplotlibPlots._finalize","title":"<code>_finalize(fig, filename)</code>","text":"<p>Internal helper to delegate finalize to PlotConfig with current flags.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <p>Matplotlib figure.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required"},{"location":"#visualizations.visualizations.MatplotlibPlots._setup_ax","title":"<code>_setup_ax(ax, title, xlabel, ylabel, grid)</code>","text":"<p>Configure basic axis properties (title, labels, grid).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>Matplotlib axis to configure.</p> required <code>title</code> <code>str</code> <p>Plot title (prefix may be added from config).</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>ylabel</code> <code>str</code> <p>Y axis label.</p> required <code>grid</code> <code>bool</code> <p>If True, enable axis grid.</p> required"},{"location":"#visualizations.visualizations.MatplotlibPlots.basic_plots","title":"<code>basic_plots(state_vector, setup)</code>","text":"<p>Generate a standard set of Matplotlib plots for the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>state_vector</code> <code>DataFrame</code> <p>DataFrame containing the simulation state over time.</p> required <code>setup</code> <code>SimulationSetup</code> <p>Simulation setup with planet data for orbit plotting.</p> required"},{"location":"#visualizations.visualizations.MatplotlibPlots.line_plot","title":"<code>line_plot(series, title, xlabel, ylabel, filename, legend=True)</code>","text":"<p>Line plot template for one or multiple series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>list[tuple[ndarray, ndarray, str]] | dict[str, tuple[ndarray, ndarray]]</code> <p>Either a dict of {label: (x, y)} or a list of (x, y, label).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>ylabel</code> <code>str</code> <p>Y axis label.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required <code>legend</code> <code>bool</code> <p>If True, show a legend.</p> <code>True</code>"},{"location":"#visualizations.visualizations.MatplotlibPlots.orbit_3d_plot","title":"<code>orbit_3d_plot(positions_km, planet_radius_km, filename='orbit', title='Orbit GCRS (ECEF)', point_size=20.0, orbit_color='r', surface_color='g')</code>","text":"<p>3D orbit visualization with a spherical Earth wireframe.</p> <p>Parameters:</p> Name Type Description Default <code>positions_km</code> <code>ndarray</code> <p>Nx3 array of position samples in km (GCRS/ECEF).</p> required <code>planet_radius_km</code> <code>float</code> <p>Planet radius in km (used to draw the sphere).</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> <code>'orbit'</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Orbit GCRS (ECEF)'</code> <code>point_size</code> <code>float</code> <p>Size of orbit points.</p> <code>20.0</code> <code>orbit_color</code> <code>str</code> <p>Color for orbit points.</p> <code>'r'</code> <code>surface_color</code> <code>str</code> <p>Color for the planet wireframe.</p> <code>'g'</code>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_angular_acceleration","title":"<code>plot_angular_acceleration(state_vector)</code>","text":"<p>Plot angular acceleration components and magnitude vs time.</p> <p>Requires: angular_acceleration_x/y/z columns (deg/s\u00b2).</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_angular_velocity","title":"<code>plot_angular_velocity(state_vector)</code>","text":"<p>Plot angular velocity components and magnitude vs time.</p> <p>Requires: angular_velocity_x/y/z columns (deg/s).</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_euler_angles","title":"<code>plot_euler_angles(state_vector)</code>","text":"<p>Plot Euler angles roll/pitch/yaw vs time (degrees).</p> <p>Requires: euler_angles_x1, euler_angles_y1, euler_angles_z1.</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_lla","title":"<code>plot_lla(state_vector)</code>","text":"<p>Plot latitude/longitude (left Y) and altitude (right Y) vs time.</p> <p>Requires: latitude, longitude, altitude columns in state_vector.</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_magnetic_field_eci","title":"<code>plot_magnetic_field_eci(state_vector)</code>","text":"<p>Plot magnetic field components in ECI frame vs time.</p> <p>Requires: magnetic_field_eci_x/y/z columns (nT).</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_magnetic_field_sbf","title":"<code>plot_magnetic_field_sbf(state_vector)</code>","text":"<p>Plot magnetic field components in SBF frame vs time.</p> <p>Requires: magnetic_field_sbf_x/y/z columns (nT).</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_orbit","title":"<code>plot_orbit(state_vector, setup)</code>","text":"<p>Plot 3D orbit using position columns from the state vector.</p> <p>Parameters:</p> Name Type Description Default <code>state_vector</code> <code>DataFrame</code> <p>DataFrame with position_x/y/z (km).</p> required <code>setup</code> <code>SimulationSetup</code> <p>Simulation setup (used to get planet radius).</p> required"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_pointing_error","title":"<code>plot_pointing_error(state_vector)</code>","text":"<p>Plot pointing error as a scatter vs time (degrees).</p> <p>Requires: pointing_error column.</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_position","title":"<code>plot_position(state_vector)</code>","text":"<p>Plot GCRS position components X/Y/Z vs time.</p> <p>Requires: position_x, position_y, position_z columns.</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_sun_vector_eci","title":"<code>plot_sun_vector_eci(state_vector)</code>","text":"<p>Plot sun vector components in ECI vs time.</p> <p>Requires: sun_vector_eci_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_sun_vector_sbf","title":"<code>plot_sun_vector_sbf(state_vector)</code>","text":"<p>Plot sun vector components in SBF vs time.</p> <p>Requires: sun_vector_sbf_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.plot_torque","title":"<code>plot_torque(state_vector)</code>","text":"<p>Plot applied magnetorquer torque components and magnitude vs time.</p> <p>Requires: torque_x/y/z columns (N\u00b7m).</p>"},{"location":"#visualizations.visualizations.MatplotlibPlots.scatter_plot","title":"<code>scatter_plot(series, title, xlabel, ylabel, filename, marker='x', legend=True)</code>","text":"<p>Scatter plot template for one or multiple series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>list[tuple[ndarray, ndarray, str]] | dict[str, tuple[ndarray, ndarray]]</code> <p>Either a dict of {label: (x, y)} or a list of (x, y, label).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>ylabel</code> <code>str</code> <p>Y axis label.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required <code>marker</code> <code>str</code> <p>Matplotlib marker style (e.g., \"x\", \"o\").</p> <code>'x'</code> <code>legend</code> <code>bool</code> <p>If True, show a legend.</p> <code>True</code>"},{"location":"#visualizations.visualizations.MatplotlibPlots.twin_axis_line_plot","title":"<code>twin_axis_line_plot(primary, secondary, title, xlabel, y1_label, y2_label, filename)</code>","text":"<p>Two-axis (left/right y) line plot.</p> <p>Parameters:</p> Name Type Description Default <code>primary</code> <code>dict[str, tuple[ndarray, ndarray]]</code> <p>Mapping label -&gt; (x, y) for the left Y axis.</p> required <code>secondary</code> <code>dict[str, tuple[ndarray, ndarray]]</code> <p>Mapping label -&gt; (x, y) for the right Y axis.</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>y1_label</code> <code>str</code> <p>Left Y axis label.</p> required <code>y2_label</code> <code>str</code> <p>Right Y axis label.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required"},{"location":"#visualizations.visualizations.PlotConfig","title":"<code>PlotConfig(output_dir, subdir='plots', dpi=300, format='png', figsize=(8.0, 6.0), style=None, grid=True, legend_loc=0, title_prefix='', color_cycle=None, linewidth=1.5, markersize=4.0, sphere_res_u=40, sphere_res_v=20)</code>  <code>dataclass</code>","text":"<p>Central configuration for plot styling and output parameters.</p> <p>This object is used by MatplotlibPlots to: - apply a consistent Matplotlib style (figure size, grid, color cycle) - define output directory and file format for saved figures - control some 3D helper parameters (e.g., sphere mesh resolution)</p> <p>Attributes:</p> Name Type Description <code>output_dir</code> <code>Path</code> <p>Base directory for outputs (plots directory is created under it).</p> <code>subdir</code> <code>str</code> <p>Subdirectory name where plots will be saved.</p> <code>dpi</code> <code>int</code> <p>Resolution for saved raster images.</p> <code>format</code> <code>str</code> <p>File extension for saved images (e.g., \"png\").</p> <code>figsize</code> <code>Tuple[float, float]</code> <p>Default figure size in inches (width, height).</p> <code>style</code> <code>Optional[str]</code> <p>Optional Matplotlib style string (e.g., \"seaborn-v0_8-paper\").</p> <code>grid</code> <code>bool</code> <p>Whether to enable grid by default on axes.</p> <code>legend_loc</code> <code>int | str</code> <p>Default legend location (int or string understood by Matplotlib).</p> <code>title_prefix</code> <code>str</code> <p>Optional prefix added to all plot titles.</p> <code>color_cycle</code> <code>Optional[Iterable[str]]</code> <p>Optional iterable of color strings to override default cycle.</p> <code>linewidth</code> <code>float</code> <p>Default line width for line plots.</p> <code>markersize</code> <code>float</code> <p>Default marker size for scatter plots.</p> <code>sphere_res_u</code> <code>int</code> <p>Horizontal resolution for orbit 3D sphere mesh.</p> <code>sphere_res_v</code> <code>int</code> <p>Vertical resolution for orbit 3D sphere mesh.</p>"},{"location":"#visualizations.visualizations.PlotConfig.plots_dir","title":"<code>plots_dir</code>  <code>property</code>","text":"<p>Ensure and return the effective directory where plots are saved.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Absolute path to the plots subdirectory.</p>"},{"location":"#visualizations.visualizations.PlotConfig.apply","title":"<code>apply()</code>","text":"<p>Apply configured Matplotlib style parameters globally.</p> Notes <p>This is called inside figure() to ensure the latest style is applied for every new figure creation.</p>"},{"location":"#visualizations.visualizations.PlotConfig.figure","title":"<code>figure(projection=None)</code>","text":"<p>Create a new Matplotlib figure/axis pair with configured defaults.</p> <p>Parameters:</p> Name Type Description Default <code>projection</code> <code>Optional[str]</code> <p>Optional 3D projection (\"3d\") or None for 2D.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(fig, ax) newly created Matplotlib figure and axis.</p>"},{"location":"#visualizations.visualizations.PlotConfig.finalize","title":"<code>finalize(fig, filename, *, save, show)</code>","text":"<p>Finalize figure lifecycle: optionally save and/or show, then close.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <p>Matplotlib figure to finalize.</p> required <code>filename</code> <code>str</code> <p>Base filename without extension for saving.</p> required <code>save</code> <code>bool</code> <p>If True, save the figure to disk using config.format and config.dpi.</p> required <code>show</code> <code>bool</code> <p>If True, show the figure window (or inline in notebooks).</p> required"},{"location":"#visualizations.visualizations.PlotlyPlots","title":"<code>PlotlyPlots(output_dir=None, save=False, show=False, renderer=None)</code>","text":"<p>Plotly plotting utilities with reusable templates and high-level helpers.</p> Notes <ul> <li>Saving produces standalone HTML files in output_dir/plots.</li> <li>Showing uses Plotly's renderer (set via the renderer argument).</li> <li>Methods return None when show=True to avoid duplicate notebook rendering.</li> </ul> <p>Initialize Plotly plot helper.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>Path | None</code> <p>Base directory for outputs (plots subfolder is created).</p> <code>None</code> <code>save</code> <code>bool</code> <p>If True, write HTML files on every plot call.</p> <code>False</code> <code>show</code> <code>bool</code> <p>If True, call fig.show() on every plot call.</p> <code>False</code> <code>renderer</code> <code>str | None</code> <p>Optional Plotly renderer (e.g., \"vscode\", \"browser\").</p> <code>None</code>"},{"location":"#visualizations.visualizations.PlotlyPlots._finalize","title":"<code>_finalize(fig, filename)</code>","text":"<p>Save/show a Plotly figure according to flags and return appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Plotly figure.</p> required <code>filename</code> <code>str</code> <p>Base output filename (without extension).</p> required <p>Returns:</p> Type Description <code>Figure | None</code> <p>Figure or None: Returns None when show=True to prevent notebook</p> <code>Figure | None</code> <p>auto-rendering duplicates; otherwise returns the figure.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots._save","title":"<code>_save(fig, filename)</code>","text":"<p>Save a Plotly figure as a standalone HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>Plotly figure.</p> required <code>filename</code> <code>str</code> <p>Base output filename (without extension).</p> required"},{"location":"#visualizations.visualizations.PlotlyPlots.basic_plots","title":"<code>basic_plots(df, setup=None)</code>","text":"<p>Generate a standard set of Plotly plots for the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>State DataFrame containing time-indexed telemetry.</p> required <code>setup</code> <p>Optional setup object used to fetch planet radius for orbit plot.</p> <code>None</code>"},{"location":"#visualizations.visualizations.PlotlyPlots.line_plot","title":"<code>line_plot(series, title, xlabel, ylabel, filename, legend=True)</code>","text":"<p>Plotly line plot template for one or multiple series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>list[tuple[ndarray, ndarray, str]] | dict[str, tuple[ndarray, ndarray]]</code> <p>Either a dict of {label: (x, y)} or a list of (x, y, label).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>ylabel</code> <code>str</code> <p>Y axis label.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required <code>legend</code> <code>bool</code> <p>If True, display legend.</p> <code>True</code>"},{"location":"#visualizations.visualizations.PlotlyPlots.orbit_3d_plot","title":"<code>orbit_3d_plot(positions_km, planet_radius_km=None, filename='orbit_plotly', title='Orbit GCRS (ECEF)', orbit_color='red', sphere_color='rgba(0,150,0,0.2)', sphere_res_u=40, sphere_res_v=20)</code>","text":"<p>Plotly 3D orbit with optional spherical body surface.</p> <p>Parameters:</p> Name Type Description Default <code>positions_km</code> <code>ndarray</code> <p>Nx3 array of positions in km (GCRS/ECEF). If None/empty, only sphere is drawn.</p> required <code>planet_radius_km</code> <code>float | None</code> <p>Planet radius in km. If provided, a semi-transparent surface is added.</p> <code>None</code> <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> <code>'orbit_plotly'</code> <code>title</code> <code>str</code> <p>Plot title.</p> <code>'Orbit GCRS (ECEF)'</code> <code>orbit_color</code> <code>str</code> <p>Color for the orbit trace.</p> <code>'red'</code> <code>sphere_color</code> <code>str</code> <p>RGBA color for the planet surface.</p> <code>'rgba(0,150,0,0.2)'</code> <code>sphere_res_u</code> <code>int</code> <p>Horizontal resolution of the planet surface grid.</p> <code>40</code> <code>sphere_res_v</code> <code>int</code> <p>Vertical resolution of the planet surface grid.</p> <code>20</code>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_angular_acceleration","title":"<code>plot_angular_acceleration(df)</code>","text":"<p>Plot angular acceleration components and magnitude vs time (deg/s\u00b2).</p> <p>Requires: angular_acceleration_x/y/z columns (magnitude only if all exist).</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_angular_velocity","title":"<code>plot_angular_velocity(df)</code>","text":"<p>Plot angular velocity components and magnitude vs time (deg/s).</p> <p>Requires: angular_velocity_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_euler_angles","title":"<code>plot_euler_angles(df)</code>","text":"<p>Plot Euler angles roll/pitch/yaw vs time (degrees).</p> <p>Requires: euler_angles_x1/y1/z1 columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_lla","title":"<code>plot_lla(df)</code>","text":"<p>Plot latitude/longitude (left) and altitude (right) vs time.</p> <p>Requires: latitude, longitude, altitude columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_magnetic_field_eci","title":"<code>plot_magnetic_field_eci(df)</code>","text":"<p>Plot magnetic field components in ECI vs time (nT).</p> <p>Requires: magnetic_field_eci_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_magnetic_field_sbf","title":"<code>plot_magnetic_field_sbf(df)</code>","text":"<p>Plot magnetic field components in SBF vs time (nT).</p> <p>Requires: magnetic_field_sbf_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_orbit","title":"<code>plot_orbit(df, planet_radius_km=None)</code>","text":"<p>High-level orbit plot from a state DataFrame with position columns.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>State DataFrame with position_x/y/z (km).</p> required <code>planet_radius_km</code> <code>float | None</code> <p>Optional planet radius in km to display a sphere.</p> <code>None</code>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_pointing_error","title":"<code>plot_pointing_error(df)</code>","text":"<p>Plot pointing error vs time as a scatter (degrees).</p> <p>Requires: pointing_error column.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_position","title":"<code>plot_position(df)</code>","text":"<p>Plot GCRS position components over time using Plotly.</p> <p>Requires: position_x, position_y, position_z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_sun_vector_eci","title":"<code>plot_sun_vector_eci(df)</code>","text":"<p>Plot sun vector components in ECI vs time.</p> <p>Requires: sun_vector_eci_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_sun_vector_sbf","title":"<code>plot_sun_vector_sbf(df)</code>","text":"<p>Plot sun vector components in SBF vs time.</p> <p>Requires: sun_vector_sbf_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.plot_torque","title":"<code>plot_torque(df)</code>","text":"<p>Plot torque components and magnitude vs time (N\u00b7m).</p> <p>Requires: torque_x/y/z columns.</p>"},{"location":"#visualizations.visualizations.PlotlyPlots.scatter_plot","title":"<code>scatter_plot(series, title, xlabel, ylabel, filename, mode='markers', legend=True)</code>","text":"<p>Plotly scatter template for one or multiple series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>list[tuple[ndarray, ndarray, str]] | dict[str, tuple[ndarray, ndarray]]</code> <p>Either a dict of {label: (x, y)} or a list of (x, y, label).</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>ylabel</code> <code>str</code> <p>Y axis label.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required <code>mode</code> <code>str</code> <p>Plotly scatter mode (e.g., \"markers\", \"lines+markers\").</p> <code>'markers'</code> <code>legend</code> <code>bool</code> <p>If True, display legend.</p> <code>True</code>"},{"location":"#visualizations.visualizations.PlotlyPlots.twin_axis_line_plot","title":"<code>twin_axis_line_plot(primary, secondary, title, xlabel, y1_label, y2_label, filename)</code>","text":"<p>Plotly two-axis (left/right y) line plot template.</p> <p>Parameters:</p> Name Type Description Default <code>primary</code> <code>dict[str, tuple[ndarray, ndarray]]</code> <p>Mapping label -&gt; (x, y) for the left Y axis.</p> required <code>secondary</code> <code>dict[str, tuple[ndarray, ndarray]]</code> <p>Mapping label -&gt; (x, y) for the right Y axis.</p> required <code>title</code> <code>str</code> <p>Plot title.</p> required <code>xlabel</code> <code>str</code> <p>X axis label.</p> required <code>y1_label</code> <code>str</code> <p>Left Y axis label.</p> required <code>y2_label</code> <code>str</code> <p>Right Y axis label.</p> required <code>filename</code> <code>str</code> <p>Base output filename without extension.</p> required"},{"location":"adcs/","title":"Introduction","text":"<p>The following code performs an ADCS (Attitude Determination and Control System) simulation for a small satellite (CubeSat). It recreates the environment on a given orbit, the object\u2019s parameters, and determines its attitude and dynamics (angular velocity and angular acceleration). The main tasks are detumbling (B-dot) and pointing (B-cross). A magnetometer, Sun sensor, and the TRIAD, QUEST, and EKF algorithms have been implemented. Control is executed using three electromagnetic coils.</p> <p>The simulation consists of three main elements:  - Reconstructing orbital and environmental conditions, including Earth\u2019s gravitational field, atmospheric drag, magnetic field, and Sun position.  - Determining the satellite\u2019s attitude and dynamics based on measurements from sensors (magnetometer, Sun sensor) and data fusion algorithms (TRIAD, QUEST, EKF).  - Controlling the satellite to carry out detumbling (reducing rotation) and pointing (orienting toward Earth or the Sun) using electromagnetic coils.</p>"},{"location":"adcs/#preparation","title":"Preparation","text":""},{"location":"adcs/#installation","title":"Installation","text":"<p>All code is written in Python and uses dedicated libraries both for mathematical operations and for implementing basic astronomical models. The remainder assumes a working Python installation (preferred 3.13). The environment is managed with Poetry. A concise installation guide is available in its documentation (https://python-poetry.org/docs/). One of the key project files for Poetry is pyproject.toml in the repository root. It defines required libraries and their versions. To ensure compatibility and proper operation, versions are pinned.</p> <p>To build the environment execute:</p> <pre><code>poetry install\n</code></pre> <p>Ways to use the environment: - Invoking poetry directly (recommended):</p> <pre><code>poetry run python adcs.py\n</code></pre> <ul> <li>Activating the environment in a terminal:</li> </ul> <pre><code>poetry env activate  # returns a personalized activation command\n# example activation (PowerShell):\n&amp; \"C:\\path\\to\\env\\Scripts\\Activate.ps1\"\npython adcs.py\ndeactivate\n</code></pre> <ul> <li>Selecting the created environment in the code editor. This step is required for using Jupyter Notebook.</li> </ul>"},{"location":"adcs/#project-structure","title":"Project Structure","text":"<pre><code>ADCS/\n\u251c\u2500 adcs.py\n\u251c\u2500 mkdocs.yml\n\u251c\u2500 pyproject.toml\n\u251c\u2500 docs/\n\u2502  \u251c\u2500 index.md\n\u2502  \u251c\u2500 adcs.md\n\u2502  \u2514\u2500 adcs_pl.md\n\u251c\u2500 core/\n\u2502  \u251c\u2500 logger.py\n\u2502  \u251c\u2500 state.py\n\u2502  \u251c\u2500 transformations.py\n\u2502  \u2514\u2500 utilities.py\n\u251c\u2500 spacecraft/\n\u2502  \u251c\u2500 actuator.py\n\u2502  \u251c\u2500 sensors.py\n\u2502  \u2514\u2500 satellite.py\n\u251c\u2500 setup/\n\u2502  \u251c\u2500 initial_settings.py\n\u2502  \u251c\u2500 initial_settings.json\n\u2502  \u251c\u2500 two_line_element.py\n\u2502  \u2514\u2500 tle\n\u251c\u2500 templates/\n\u2502  \u251c\u2500 actuator_template.py\n\u2502  \u251c\u2500 sensor_template.py\n\u2502  \u251c\u2500 satellite_template.py\n\u2502  \u251c\u2500 two_line_element_template.py\n\u2502  \u2514\u2500 initial_settings_template.py\n\u251c\u2500 visualizations/\n\u2502  \u2514\u2500 visualizations.py\n\u2514\u2500 tests/\n   \u251c\u2500 conftest.py\n   \u251c\u2500 test_actuator.py\n   \u251c\u2500 test_sensors.py\n   \u2514\u2500 test_transformations.py\n</code></pre> <p>The backbone of the project is the spacecraft folder, which contains the core code responsible for satellite systems. - The satellite.py script handles general management and coordination of individual elements, integrating everything into a single object through which key satellite parameters can be accessed. - The sensors.py script contains all code related to measurements: environment simulation, adding noise, and processing via algorithms (TRIAD, QUEST, EKF). - The actuator.py script handles active elements (in this case only electromagnetic coils). Its role is implementing control algorithms (detumbling and pointing) and managing operation to achieve the expected effect.</p> <p>The core folder contains helper functions, mainly related to mathematical operations and broadly defined spatial attitude handling and its processing. - logger.py contains the configured logging module. - state.py manages the state vector. - transformations.py focuses on functions related to attitude, such as frame conversions, quaternion operations, and rotations. - utilities.py contains all remaining helpful functions like date format conversion.</p> <p>The setup folder gathers information related to simulation settings, input data, and scripts responsible for processing them. - The tle file stores the Two-Line Element Set describing orbital parameters. - two_line_element.py loads it and extracts parameters conveniently. - initial_settings.json stores parameters and settings describing initial state, constants, satellite parameters, and modes. Most variables affecting simulation flow can be managed from it. - initial_settings.py loads and manages settings from initial_settings.json.</p> <p>The visualizations folder is related to plots that allow checking simulation progress. - visualizations.py contains code responsible for creating plots.</p> <p>The templates folder defines files that form skeletons describing basic contents of key repository elements. Their parameters are required by implementation scripts.</p>"},{"location":"adcs/#first-run","title":"First Run","text":"<p>Execution can occur in two ways. After building the environment either run adcs.py, which contains an integrated simulation, or use a Jupyter Notebook. With default settings the code will run and should produce normal logs:</p> <pre><code>2025-11-14 23:42:20 | INFO | Simulation initialized with the following parameters:\n2025-11-14 23:42:20 | INFO | Number of iterations: 10000\n2025-11-14 23:42:20 | INFO | Satellite mass: 1.2 kg\n2025-11-14 23:42:20 | INFO | Satellite inertia: [[0.002 0.    0.   ]\n [0.    0.002 0.   ]\n [0.    0.    0.002]] kg*m^2\n2025-11-14 23:42:20 | INFO | Initial angular velocity: [ 2. -3.  4.] deg/s\n2025-11-14 23:42:20 | INFO | Initial attitude (Euler angles): [0. 0. 0.] deg\n2025-11-14 23:42:20 | INFO | Selected sensor fusion algorithm: EKF\n2025-11-14 23:42:20 | INFO | Magnetometer noise: 10.0 nT\n2025-11-14 23:42:20 | INFO | Sunsensor noise: 0.2 deg\n2025-11-14 23:42:20 | INFO | Sensor on time: 2 seconds, actuator on time: 8 seconds\n\n2025-11-14 23:42:20 | INFO | Iteration 0 of 10000\n2025-11-14 23:42:25 | INFO | Iteration 100 of 10000\n</code></pre> <p>This form means the code runs correctly.</p>"},{"location":"adcs/#fundamentals","title":"Fundamentals","text":"<p>Below the key theoretical concepts are briefly presented with usage examples and references to their application in simulation code. Since some functions and methods were prepared specifically for this repository, correct functioning requires initialization of base objects and parameters. This can be done with the following code (in most cases placed at the beginning):</p> <pre><code>from pathlib import Path\nfrom spacecraft.satellite import SatelliteImplementation\nfrom setup.initial_settings import SimulationSetupReader\nfrom setup.two_line_element import TwoLineElementReader\nfrom spacecraft.sensors import MagnetometerImplementation, SunsensorImplementation, SensorFusionImplementation\n\nsetup = SimulationSetupReader(Path('setup/initial_settings.json'))\ntle = TwoLineElementReader(Path('setup/tle'))\nmagnetometer = MagnetometerImplementation(setup)\nsunsensor = SunsensorImplementation(setup)\nsensor_fusion = SensorFusionImplementation(setup, ['triad', 'quest', 'ekf'], tr.euler_xyz_to_quaternion(setup.euler_angles))\n\nsatellite = SatelliteImplementation(setup, tle, magnetometer, sunsensor, sensor_fusion)\n</code></pre>"},{"location":"adcs/#orbit-and-environment","title":"Orbit and Environment","text":""},{"location":"adcs/#julian-date-jd","title":"Julian Date (JD)","text":"<p>The Julian Date is a frequently used time representation in astronomical computations and algorithms. It is the fraction representing the number of days since noon January 1, 4713 BC. For example, for UTC 2025-10-18 00:00:00.000 JD equals 2460966.5. Sometimes the Modified Julian Date (MJD) format is encountered, intended to simplify the fraction: MJD = JD \u2212 2400000.5. For the above example it is 60966. The code uses the standard JD applied in the Skyfield library. It is passed as an argument to the propagator model and allows obtaining orbital parameters. Conversion is handled by a function returning current satellite time (simulation start time plus iteration count). With default settings using current time as start:</p> <pre><code>import core.utilities as ut\n\ntime_satellite = satellite.setup.date_time\nsatellite_julian_date = ut.time_julian_date(satellite)\n\nprint(f\"Satellite time: {time_satellite}\")\nprint(f\"Satellite Julian date: {satellite_julian_date}\")\n</code></pre> <p>Example output:</p> <pre><code>Satellite time: 2025-10-22 13:25:41.386584\nSatellite Julian date: &lt;Time tt=2460818.709556771&gt;\n</code></pre> <p>Note: Skyfield presents time in TT (Terrestrial Time). It differs from UTC by \u0394T (leap seconds and drift). For IGRF this is negligible, but for precise conversions TT\u2194UTC should be considered.</p>"},{"location":"adcs/#tle","title":"TLE","text":"<p>The most popular storage format for parameters of Earth-orbiting objects is the TLE (Two-Line Element Set), which consists of two lines where each character sequence has meaning. An example used in this repository (also under ADCS/setup/tle):</p> <pre><code>1 25544U 98067A 25143.20875603 .00008836 00000-0 16445-3 0 9994\n2 25544 51.6382 70.8210 0002488 135.0606 10.4960 15.49676890511280\n</code></pre> <p>To load and extract data from TLE conveniently, code (two_line_element.py) was created. It allows retrieving individual elements by name or entire lines as strings. Meanings are briefly added in function descriptions. A good summary is available on Wikipedia (https://en.wikipedia.org/wiki/Two-line_element_set).</p> <p>Initialize TLE to use it:</p> <pre><code>print(f'Two Line Element:\\n{tle.line_1}\\n{tle.line_2}')\n\nprint(f\"Epoch Year: {tle.epoch_year}\")\nprint(f\"Epoch Day: {tle.epoch_day}\")\n\nprint(f\"Inclination: {tle.inclination}\")\nprint(f\"Bstar Drag: {tle.bstar_drag}\")\n</code></pre> <p>Output:</p> <pre><code>Two Line Element:\n1 25544U 98067A 25143.20875603 .00008836 00000-0 16445-3 0 9994\n2 25544 51.6382 70.8210 0002488 135.0606 10.4960 15.49676890511280\nEpoch Year: 25\nEpoch Day: 143.20875603\nInclination: 51.6382\nBstar Drag: 16445-3\n</code></pre> <p>Note the format: Bstar Drag \u201c16445-3\u201d must be interpreted as 0.16445e-3 (1.6445e-4).</p>"},{"location":"adcs/#propagator","title":"Propagator","text":"<p>The orbital propagator determines satellite position, velocity, and acceleration at a given moment. This simulation uses SGP4 (Simplified General Perturbations 4). It uses TLE data and requires periodic updates to limit growing errors. Implementation comes from Skyfield.</p> <pre><code>import skyfield.api as skyfield\n\nsatellite_model = skyfield.EarthSatellite(tle.line_1, tle.line_2)\njulian_date = ut.time_julian_date(satellite)\n\nposition = satellite_model.at(julian_date).position.km\nvelocity = satellite_model.at(julian_date).velocity.km_per_s\n\nprint(f\"Position vector: {position} [km]\")\nprint(f\"Velocity vector: {velocity} [km/s]\")\n</code></pre> <p>Example output:</p> <pre><code>Position vector: [-4107.48809952 -4489.58941621  3014.80595056] [km]\nVelocity vector: [ 2.23875988 -5.3942253  -4.96501356] [km/s]\n</code></pre> <p>Position and velocity are primary results, but altitude above the WGS\u201184 ellipsoid, geographic longitude and latitude can also be obtained. Skyfield results are in GCRS (inertial, aligned with ICRF at J2000); \u201cECI\u201d is used as shorthand. If raw SGP4/TEME is used, transform to ECEF/ITRF (precession, nutation, sidereal time).</p> <p>More: https://www.aero.iitb.ac.in/satelliteWiki/index.php/Orbit_Propagator</p>"},{"location":"adcs/#low-earth-orbit-leo","title":"Low Earth Orbit (LEO)","text":"<p>The region of space extending from Earth up to the Van Allen belts is referred to as Low Earth Orbit. In practice altitudes from about 200 km to 2000 km are considered. It is popular due to proximity and lower launch cost. Drawbacks include residual atmospheric drag (especially below ~300 km) and limited field of view. From an attitude determination and control perspective proximity to Earth offers another advantage: relatively strong magnetic field usable by sensors and actuators.</p>"},{"location":"adcs/#earths-magnetic-field","title":"Earth\u2019s Magnetic Field","text":"<p>Earth naturally generates a magnetic field internally and around itself. Its shape approximates a dipole slightly tilted from the rotation axis. It has static and variable components (the latter typically 1\u20135%). Local anomalies exist. Thanks to observations accurate models such as IGRF (International Geomagnetic Reference Field) were developed. This simulation uses pyIGRF. It requires geographic coordinates and date as a decimal fraction (time from start of year expressed as a fraction, e.g. 2024.25 as first quarter).</p> <pre><code>import pyIGRF\nimport core.utilities as ut\nimport datetime\n\nlat = satellite.latitude\nlon = satellite.longitude\nalt_km = satellite.altitude\njulian_date = ut.time_julian_date(satellite)\n\ndt = julian_date.utc_datetime()\nstart = datetime.datetime(dt.year, 1, 1, tzinfo=dt.tzinfo)\nend = datetime.datetime(dt.year + 1, 1, 1, tzinfo=dt.tzinfo)\ndecimal_year = dt.year + (dt - start).total_seconds() / (end - start).total_seconds()\n\n# IGRF returns NED components in nT\nd, i, h, b_n, b_e, b_d, f = pyIGRF.igrf_value(lat, lon, alt_km, decimal_year)\n\nprint(f\"IGRF Magnetic Field NED: B_n={b_n:.2f}, B_e={b_e:.2f}, B_d={b_d:.2f} [nT]\")\nprint(f\"IGRF Magnetic Field Magnitude: F={f:.2f} [nT]\")\nprint(f\"IGRF Declination: D={d:.2f} [deg], Inclination: i={i:.2f} [deg], Horizontal Intensity: H={h:.2f} [nT]\")\n</code></pre> <p>Output:</p> <pre><code>IGRF Magnetic Field NED: B_n=20470.13, B_e=-760.77, B_d=29507.77 [nT]\nIGRF Magnetic Field Magnitude: F=35920.94 [nT]\nIGRF Declination: D=-2.13 [deg], Inclination: i=55.23 [deg], Horizontal Intensity: H=20484.26 [nT]\n</code></pre> <p>The library returns vector and resultant field value, declination, inclination, and horizontal intensity. For ADCS only the vector matters. Note pyIGRF returns NED (North-East-Down); transform before further work (see transformations chapter).</p> <p>More: https://geomag.bgs.ac.uk/research/modelling/IGRF</p>"},{"location":"adcs/#sun-position","title":"Sun Position","text":"<p>The Sun and its position are another element useful for attitude determination in space due to well-predictable position relative to Earth. Considering the enormous distance between both bodies, for simple calculations on low orbits Earth-centric description suffices, ignoring satellite orbital motion. A good step-by-step description can be found on Wikipedia: https://en.wikipedia.org/wiki/Position_of_the_Sun</p> <p>Here Skyfield is used to compute Sun vector relative to Earth for a given Julian Date.</p> <pre><code>import skyfield.api as skyfield\nimport core.utilities as ut\n\n# load ephemeris data for sun and earth\neph = skyfield.load('de421.bsp')\nsun = eph['sun']\nearth = eph['earth']\n\njulian_date = ut.time_julian_date(satellite)\n\nsun_position_eci = earth.at(julian_date).observe(sun).position.km\n\nprint(f\"Sun Position ECI: {sun_position_eci} [km]\")\n</code></pre> <p>Output:</p> <pre><code>Sun Position ECI: [7.11550861e+07 1.22678186e+08 5.31785009e+07] [km]\n</code></pre> <p>Returned Sun vector is in ICRF (treated as \u201cECI\u201d for simplicity).</p>"},{"location":"adcs/#attitude-and-transformations","title":"Attitude and Transformations","text":""},{"location":"adcs/#reference-frames","title":"Reference Frames","text":"<p>To determine spatial attitude frames must be established. Due to diversity of objects and applications in space a range of different frames is used. Below several appearing in this repository are described.</p> <ul> <li>Satellite Body (SB) \u2013 frame rigidly attached to the spacecraft, moving and rotating with it. In this simplified simulation it is tied to sensors; measurements are expressed in it. In practice a navigation base may be defined and sensors may have local frames.</li> <li>Earth-Centered Inertial (ECI) \u2013 Earth-centered frame fixed relative to distant stars. Z axis toward North Pole, X along intersection of equator and ecliptic, Y completing orthonormal basis. Origin at Earth\u2019s center of mass. Practically GCRS (ICRF-aligned) often used.</li> <li>Earth-Centered Earth-Fixed (ECEF) \u2013 rotating with Earth. Z along Earth\u2019s rotation axis, X intersection of equator and 0\u00b0 meridian, Y intersection of equator and 90\u00b0E meridian.</li> <li>East-North-Up / North-East-Down (ENU / NED) \u2013 two variants of a local frame near Earth. First two axes (X and Y) oriented along east or north direction; main difference lies in Z, pointing away from Earth (Up) or toward Earth (Down). ENU: x=East, y=North, z=Up. NED: x=North, y=East, z=Down. Appears for magnetic field (IGRF models return values in this frame).</li> <li>International Celestial Reference Frame (ICRF) \u2013 inertial frame with origin at Solar System barycenter; used for ephemerides. For near-Earth orbits treated as \u201cECI\u201d.</li> <li>Longitude / Latitude / Altitude (LLA) \u2013 geodetic form relative to WGS\u201184.</li> </ul>"},{"location":"adcs/#attitude-representation-and-rotation","title":"Attitude Representation and Rotation","text":"<p>For an ADCS system on low Earth orbit the most important frames are ECI and SBF where the former is reference and the latter tied to onboard measurements. Transition between them consists of translation and rotation. Translation is provided by the propagator returning satellite position at a moment. Finding the rotation representing spatial attitude is ADCS task achieved using sensor measurements and comparing them with reference. Attitude can be represented several ways:</p> <ul> <li>Euler Angles \u2013 three successive rotations about chosen axes. Intuitive (popular e.g. in aviation) but limited for space applications (e.g. gimbal lock). In code used for initialization and visualization.</li> <li>Quaternion \u2013 q = [u_x sin(\u03b1/2), u_y sin(\u03b1/2), u_z sin(\u03b1/2), cos(\u03b1/2)]. Four-element rotation representation consisting of vector and scalar part. Vector part corresponds to rotation axis u, scalar part is cos(\u03b1/2). Quaternion is compact, convenient, numerically stable, and free of Euler angle singularities.</li> <li>Rotation Matrix \u2013 most basic form: a matrix that multiplies the original vector to obtain the target vector.</li> </ul> <p>Rotation handling can be tricky and error-prone; to minimize risk the reliable scipy library is used for most operations. Below an example of a simple rotation using Euler angles and quaternion:</p> <pre><code>import scipy.spatial.transform as R\n\neuler_angles_init = [90.0, 0.0, 0.0]  # degrees\nquaternion_init = [0.70710678, 0.0, 0.0, 0.70710678]  # [x, y, z, w]\n\nreproduced_quaternion = R.Rotation.from_euler('xyz', euler_angles_init, degrees=True).as_quat()\nreproduced_euler_angles = R.Rotation.from_quat(quaternion_init).as_euler('xyz', degrees=True)\n\nprint(f\"Initial Euler Angles: {euler_angles_init} [deg]\")\nprint(f\"Initial Quaternion: {quaternion_init} [x, y, z, w]\")\nprint(f\"Reproduced Quaternion from Euler Angles: {reproduced_quaternion} [x, y, z, w]\")\nprint(f\"Reproduced Euler Angles from Quaternion: {reproduced_euler_angles} [deg]\")\n\nv1 = [0.0, 1.0, 0.0]\n\nrotation = R.Rotation.from_quat(quaternion_init)\nv2 = rotation.apply(v1)\n\nprint(f\"Original Vector: {v1}\")\nprint(f\"Rotated Vector: {v2}\")\n</code></pre> <p>Output:</p> <pre><code>Initial Euler Angles: [90.0, 0.0, 0.0] [deg]\nInitial Quaternion: [0.70710678 0.         0.         0.70710678] [x, y, z, w]\nReproduced Quaternion from Euler Angles: [0.70710678 0.         0.         0.70710678] [x, y, z, w]\nReproduced Euler Angles from Quaternion: [90.  0.  0.] [deg]\nOriginal Vector: [0.0, 1.0, 0.0]\nRotated Vector: [0. 0. 1.]\n</code></pre> <p>Note: after each update the quaternion should be normalized to limit numerical drift.</p> <p>Similarly functions for transitioning between frames were created (core/transformations.py). Below five basic implemented conversions:</p> <pre><code>import core.transformations as tr\nimport core.utilities as ut\n\nv1 = [0.0, 1.0, 0.0]\njulian_date = ut.time_julian_date(satellite)\nquaternion_init = [0.70710678, 0.0, 0.0, 0.70710678]\n\nenu_ecef = tr.enu_to_ecef(v1, satellite.latitude, satellite.longitude)\nned_ecef = tr.ned_to_ecef(v1, satellite.latitude, satellite.longitude)\necef_eci = tr.ecef_to_eci(v1, julian_date)\neci_sbf = tr.eci_to_sbf(v1, quaternion_init)\nsbf_eci = tr.sbf_to_eci(v1, quaternion_init)\n\nprint(f\"Original Vector: {v1}\")\nprint(f\"ENU to ECEF: {enu_ecef}\")\nprint(f\"NED to ECEF: {ned_ecef}\")\nprint(f\"ECEF to ECI: {ecef_eci}\")\nprint(f\"ECI to SBF: {eci_sbf}\")\nprint(f\"SBF to ECI: {sbf_eci}\")\n</code></pre> <p>Output:</p> <pre><code>Original Vector: [0.0, 1.0, 0.0]\nENU to ECEF: [ 0.02791803  0.44449952 -0.89534393]\nNED to ECEF: [ 0.99961022 -0.01241439  0.02500598]\nECEF to ECI: [0.69189531 0.72199784 0.        ]\nECI to SBF: [0. 0. 1.]\nSBF to ECI: [ 0.  0. -1.]\n</code></pre>"},{"location":"adcs/#sensors-and-active-elements","title":"Sensors and Active Elements","text":""},{"location":"adcs/#magnetometers","title":"Magnetometers","text":"<p>A magnetometer measures the magnetic field. There are many types of magnetometers with different capabilities and sizes depending on application and mission character. For small satellites on low Earth orbit three-axis magnetometers are used. Often they are fluxgate (core saturation) or magnetoresistive devices. Miniaturization yields small, light, low-power units.</p> <p>In this simulation the magnetometer was chosen as the main sensor. Magnetometer simulation uses magnetic field from the IGRF model. To obtain a value equivalent to an actual onboard measurement, the vector must be transformed to the SBF frame. Noise can be added using a maximum absolute deviation.</p> <pre><code>mag_field_sbf += noise_vector\n</code></pre> <p>where noise_vector = &lt;-x: +x&gt;.</p> <p>Noise settings are in initial_settings.json:</p> <pre><code>\"Magnetometer\":\n{\n  \"Noise\": true,\n  \"AbsoluteNoise\": 10,\n  \"UnitInfo\": \"nT\"\n},\n</code></pre> <p>Noise model is simplified (uniform \u00b1A per axis). Real sensors more often exhibit Gaussian distribution + bias + drift.</p>"},{"location":"adcs/#sun-sensor","title":"Sun Sensor","text":"<p>Sun sensors enable determination of the Sun vector (direction of the Sun relative to the satellite). Depending on role they may be highly accurate array sensors or simpler multi-photodiode units on exterior panels. The latter is common on small satellites. Due to simplicity they complement other sensors well. In this case typically treated as second sensor.</p> <p>Relative Sun position is obtained using Skyfield (as described earlier), then transformed to SB frame for an equivalent onboard measurement vector. It can then be noisified. Sun sensor noise is implemented as rotation of the vector around a random axis by a random angle in the specified range.</p> <pre><code>sun_vector = raw_sun_vector * R\n</code></pre> <p>where R is a rotation matrix representing rotation by an angle from &lt;-x: +x&gt;.</p> <p>Noise settings in initial_settings.json:</p> <pre><code>\"SunSensor\":\n{\n  \"Noise\": true,\n  \"AngularNoise\": 0.2,\n  \"UnitInfo\": \"deg\"\n},\n</code></pre>"},{"location":"adcs/#gyroscopes","title":"Gyroscopes","text":"<p>A gyroscope measures angular velocity directly (not angular acceleration). Classically it is a large rotating mechanical device using conservation of angular momentum. In space missions MEMS gyros are typically used\u2014devices with small vibrating elements measuring rotation via Coriolis force. They are small and inexpensive, but have limited accuracy and accumulating drift. In this simulation angular velocity can be determined from attitude difference between iterations: divide by \u0394t and preferably use quaternion derivative (\u03c9 = 2 q\u0307 \u2297 q\u207b\u00b9). Drift is not modeled in detail.</p> <pre><code>\"Gyroscope\":\n{\n  \"Bias\": [0.0, 0.0, 0.0],\n  \"ProcessNoise\": [1e-8, 1e-8, 1e-8],\n  \"UnitInfo\": \"deg/s\"\n},\n</code></pre>"},{"location":"adcs/#sensor-fusion","title":"Sensor Fusion","text":"<p>A basic problem in attitude determination is combining measurements from two or more sources to obtain a single more reliable and accurate estimate. Using multiple types balances potential shortcomings when one would perform worse. Specialized algorithms process measurements. In space missions three are often distinguished:</p> <ul> <li>TRIAD (Three-Axis Attitude Determination) \u2013 simplest. Processes measurements from only two sensors knowing vectors in satellite frame and their inertial counterparts. Finds rotation matrix by constructing triads and relative arrangement.</li> <li>QUEST (QUaternion ESTimator) \u2013 solves Wahba\u2019s problem for two or more vectors. Returns a quaternion (eigenvector of matrix built from measurement data). Optionally assigns weights to measurements.</li> <li>EKF (Extended Kalman Filter) \u2013 more advanced nonlinear state estimation. Iteratively uses dynamic model to predict future state and sensor measurements to correct it. For ADCS it uses measurement pairs plus angular velocity and previous attitude. EKF estimates should be noticeably more accurate than TRIAD and QUEST. Below an example obtaining quaternion for two vectors rotated by 90 degrees at zero angular velocity.</li> </ul> <pre><code>import numpy as np\n\n# two reference vectors\nv1_i = np.array([1.0, 0.0, 0.0])\nv2_i = np.array([0.70710678, 0.70710678, 0.0])\n\n# two measured vectors with some noise rotated by 90 deg around z axis\nv1_b = np.array([0.0, 1.0, 0.0]) + np.random.uniform(-0.02, 0.02, size=3)\nv2_b = np.array([-0.70710678, 0.70710678, 0.0]) + np.random.uniform(-0.05, 0.05, size=3)\n\nq_reference = np.array([0.0, 0.0, 0.70710678, 0.70710678])\n\n# typically the first vector should be the most accurate one\nv_i_list = [v1_i, v2_i]\nv_b_list = [v1_b, v2_b]\n\n# normalize before estimation (TRIAD/QUEST/EKF)\nv_i_list = [v/np.linalg.norm(v) for v in v_i_list]\nv_b_list = [v/np.linalg.norm(v) for v in v_b_list]\n\nq_triad = sensor_fusion.triad(v_b_list, v_i_list)\nq_quest = sensor_fusion.quest(v_b_list, v_i_list)\nq_ekf = sensor_fusion.ekf(v_b_list, v_i_list, np.array([0.0, 0.0, 0.0, 0.0]), 1, q_reference)\n\n# signs may differ between algorithms, but represent the same rotation q = -q\nprint(f\"Reference quaternion: {q_reference} [x, y, z, w]\")\nprint(f\"TRIAD Quaternion: {q_triad} [x, y, z, w]\")\nprint(f\"QUEST Quaternion: {q_quest} [x, y, z, w]\")\nprint(f\"EKF Quaternion: {q_ekf} [x, y, z, w]\")\n</code></pre> <p>Output:</p> <pre><code>Reference quaternion: [0.         0.         0.70710678 0.70710678] [x, y, z, w]\nTRIAD Quaternion: [-0.01693025 -0.01254686  0.7105929   0.70328776] [x, y, z, w]\nQUEST Quaternion: [-0.01691007 -0.01257405  0.70946175  0.70442883] [x, y, z, w]\nEKF Quaternion: [-0.00855144 -0.00616122  0.70900606  0.70512362] [x, y, z, w]\n</code></pre> <p>QUEST estimate is slightly better than TRIAD, but EKF is closest (result differs due to random noise). Selection of fusion algorithm and parameters is set in initial_settings.json (TRIAD has no extra parameters).</p>"},{"location":"adcs/#electromagnetic-coils","title":"Electromagnetic Coils","text":"<p>Sensors provide reliable information about satellite dynamics and attitude; active elements use it for control consistent with mission profile. Electromagnetic coils (magnetorquers) are basic control elements for small satellites on low Earth orbit. Most often three-axis coil assemblies on magnetic or air cores. Air-core assumed here (easier integration).</p> <p>Operation basis: a coil with current generates magnetic dipole. Interacting with Earth\u2019s magnetic field produces a torque:</p> <pre><code>\u03c4 = m \u00d7 B\n</code></pre> <p>Units: m [A\u00b7m\u00b2], B [T], \u03c4 [N\u00b7m].</p> <p>Control is limited by locally weak field and geometry: when required moment is parallel to B, m \u00d7 B \u2248 0 and control becomes ineffective.</p> <p>Parameters in initial_settings.json:</p> <pre><code>\"Magnetorquer\": {\n  \"Coils\": 200,\n  \"MaxCurrent\": 0.2,\n  \"CoilArea\": 90,\n  \"SafetyFactor\": 0.9,\n  \"AlphaCap\": 0.5,\n  \"UnitInfo\": \"coils, cm^2, A, unitless, deg/s2\"\n}\n</code></pre> <p>Note: CoilArea in cm\u00b2 converted to m\u00b2 (\u00d71e\u20114).</p>"},{"location":"adcs/#simulation","title":"Simulation","text":"<p>These components form a model enabling simulation of a small satellite on Earth orbits.</p>"},{"location":"adcs/#input-settings","title":"Input Settings","text":"<p>To simplify management of all parameters affecting simulation flow they were placed in a JSON file and initial_settings.py created to manage it. This allows control over each stage without editing underlying code. Multiple variants can be created since the JSON path is passed as an input parameter rather than hard-coded. Entire configuration is grouped like a Python dict with five top-level keys and more detailed nested ones. An informational unit entry appears for parameters (not processed).</p> <ul> <li>Simulation \u2013 basic simulation parameters such as physical constants, iteration control, start date.</li> <li>Satellite \u2013 parameters describing the satellite: mass, inertia, initial attitude.</li> <li>Sensors \u2013 parameters related to sensors and measurements; includes sensor settings and fusion algorithm parameters.</li> <li>Actuators \u2013 parameters of active elements (here only coil): number of turns, cross-sectional area, safety factor, acceleration cap.</li> <li>Controls \u2013 parameters related to satellite control: fusion algorithm choice, detumbling and pointing algorithm settings, mode switching.</li> </ul> <p>initial_settings.py is prepared for current structure. Missing required keys raise errors, but additional entries can be added. If added at leaf level they are simply appended. Adding a unit is optional. Example:</p> <pre><code>\"Magnetorquer\":\n{\n  \"Coils\": 200,\n  \"MaxCurrent\": 0.2,\n  \"CoilArea\": 90,\n  \"SafetyFactor\": 0.9,\n  \"AlphaCap\": 0.5,\n  \"WireDia\": 0.8,\n  \"UnitInfo\": \"coils, cm^2, A, unitless, deg/s2, mm\"\n}\n</code></pre> <p>Then in the defined dict it appears as a key:</p> <pre><code>setup.magnetorquer_params[\"WireDia\"]\n</code></pre> <p>If an entry is added elsewhere it goes to other parameters stored in self.other_parameters:</p> <pre><code>{\n  \"Simulation\": { \"PlanetConst\": ... },\n  \"SomeOtherData\": {\n    \"A\": 2,\n    \"B\": 4\n  }\n}\n</code></pre> <p>Loaded identically:</p> <pre><code>data_dict = setup.other_parameters[\"SomeOtherData\"]\nA = data_dict[\"A\"]\nB = data_dict[\"B\"]\n</code></pre>"},{"location":"adcs/#satellite-parameters","title":"Satellite Parameters","text":"<p>To simplify satellite operations it is treated as an object composed of components and key describing parameters are defined as properties in satellite.py. Note initialization:</p> <pre><code>satellite = SatelliteImplementation(setup, tle, magnetometer, sunsensor, sensor_fusion)\n</code></pre> <p>So elements affecting satellite state are input data, TLE, magnetometer, Sun sensor, and fusion algorithm. Both constant parameters and updating ones describing current state can be accessed. Predefined properties appear as hints in editor and their description can be shown quickly. Example parameters:</p> <pre><code>print(satellite.angular_velocity)\nprint(satellite.inertia_matrix)\nprint(satellite.magnetic_field)\nprint(satellite.torque)\n</code></pre> <p>Output:</p> <pre><code>[  8. -14.  11.]\n[[0.002 0.    0.   ]\n [0.    0.002 0.   ]\n [0.    0.    0.002]] (array([-12117.938582  , -12371.50694404, -31464.45657624]), array([-12121.11401262, -12375.32291477, -31468.13563725]))\n[0. 0. 0.]\n</code></pre>"},{"location":"adcs/#algorithms","title":"Algorithms","text":"<p>Satellite behavior is based on implemented control algorithms. Their definition depends on mission character, available sensors, and actuators. Three basic states for satellites: detumbling (reducing rotation), pointing (target alignment), and off state. Transitions defined by achieving certain criteria and found in initial_settings.json.</p>"},{"location":"adcs/#detumbling-b-dot","title":"Detumbling (B-dot)","text":"<p>Reducing angular velocity is usually the first and most important control task. A deployed satellite often reaches orbit rotating relatively fast uncontrollably. To proceed to mission operations spatial attitude must be stabilized by slowing to a threshold. Bringing and maintaining sufficiently low rotation is detumbling\u2019s task. For the assumed use of only electromagnetic coils in this project it is implemented via B-dot. Its name and operation relate to magnetic field derivative. Change rate of measured field is proportional to angular velocity components. Practically generated dipole must oppose rotation direction and be scaled by a gain.</p> <pre><code>m = -k * dB/dt\n</code></pre> <p>There are several modifications helpful in certain cases. For an example 1U satellite differences are small. Below variants:</p> <ul> <li>Modified B-dot \u2013 does not rely on field derivative but directly on measured angular velocity. Less sensitive to field perturbations but requires angular velocity source.</li> </ul> <pre><code>m = -k (\u03c9 \u00d7 B)\n</code></pre> <ul> <li>Proportional B-dot \u2013 adds damping term based also on angular velocity. Can stabilize under changing field but if too strong may cause oscillations or destabilize at low speeds.</li> </ul> <pre><code>m = -k * dB/dt - k_p * \u03c9\n</code></pre> <ul> <li>Speed adaptive \u2013 same principle but gain depends on current angular velocity relative to a reference threshold. Above increased, below decreased. Speeds initial reduction but smooths controller later; may hinder damping at very low speeds.</li> </ul> <pre><code>k = k * (|\u03c9|/\u03c9_ref)^a\n</code></pre> <ul> <li>Field adaptive \u2013 also modifies gain only. Depends on absolute magnetic field value relative to a reference (often near Earth average ~45000 nT). Helps mitigate orbital variation influence: increases gain when field weakens, decreases when it strengthens.</li> </ul> <pre><code>k = k * (B_ref/|B|)^b\n</code></pre> <p>Variants can combine. In most cases basic B-dot suffices. Algorithm is simple and reliable; for a small satellite it should reduce even large speeds quickly; time spans from under one hour to a few (simulation time) depending on initial conditions. Resulting angular velocity plot should smoothly converge to 0 resembling 1/x. If oscillations, direction changes, or instability are observed verify parameters.</p> <ul> <li>Gain \u2013 primary scaling converting derivative to sufficiently large dipole within coil capabilities. For example 1U values between 1000 and 4000 are sufficient; larger satellites can increase accordingly. Monitor coil load: if at max for long periods reduce gain; if very low for long periods increase. Auxiliary parameter: speed drop\u2014too slow suggests gain too small.</li> <li>Proportional gain \u2013 auxiliary; value should remain small. Considering direct combination with angular velocity in radians use values between 0.05 and 0.6.</li> </ul> <p>Satellite mass, inertia matrix, and coil parameters must be considered; though not in algorithm they are key for converting dipole to torque.</p>"},{"location":"adcs/#pointing-b-cross","title":"Pointing (B-cross)","text":"<p>WARNING: This element remains under development and is not fully stable.</p> <p>Pointing orients a given satellite face toward a target. For near-Earth objects typically Earth (e.g. camera) or Sun (e.g. solar panels). One algorithm usable with coils is B-cross. It relies on cross products minimizing angle between two vectors (target and current). Basic version has alignment and damping components:</p> <pre><code>m = m_align + m_damp = k_a (error_vector \u00d7 B) + k_d (\u03c9 \u00d7 B)\n</code></pre> <p>A normalized variant relative to magnetic field is often used for stability; it changes gain magnitudes:</p> <pre><code>m = m_align + m_damp = k_a (error_vector \u00d7 B)/||B||^2 + k_d (\u03c9 \u00d7 B)/||B||^2\n</code></pre> <p>Using only coils brings difficulties: sensitivity to local field variation, inability to generate moment when component is parallel, gain tuning trouble, limited precise control. Thus algorithm is used for initial alignment or coarse pointing.</p>"},{"location":"adcs/#computing-angular-acceleration","title":"Computing Angular Acceleration","text":"<p>Theoretical magnetic dipole from coils is first step to desired angular acceleration. First convert components to required coil current considering turns and cross-sectional area:</p> <pre><code>i = m / (n_coils * A_coil)\n</code></pre> <p>A in m\u00b2 (from RodArea_cm2 \u00d7 1e\u20114). Torque \u03c4 equals sum of magnetic torque and disturbance torques:</p> <pre><code>\u03c4_total = \u03c4_mag + \u03c4_bias\n\u03c4_mag = m \u00d7 B\n\u03b1 = I^{-1} ( \u03c4_total \u2212 \u03c9 \u00d7 (I \u03c9) )\n</code></pre> <p>where:</p> <pre><code>coriolis = \u03c9 \u00d7 (I * w)\n</code></pre> <p>After obtaining acceleration apply caps to reduce destabilization from abrupt spikes. Scale current accordingly.</p>"},{"location":"adcs/#mode-switching","title":"Mode Switching","text":"<p>Each mode has defined start and end parameters. Transitions are automatic and defined in initial_settings.json:</p> <pre><code>\"ModeManagement\":\n{\n  \"DetumblingOff\": 0.5,\n  \"DetumblingOn\": 1.0,\n  \"PointingOff\": 10.0,\n  \"PointingOn\": 12.0,\n  \"PointingDwellTime\": 90,\n  \"UnitInfo\": \"deg/s, deg, deg, deg, s\"\n}\n</code></pre> <p>For detumbling key is angular speed; for pointing maintaining angular error within bounds for dwell time. Thresholds have hysteresis: PointingOff &lt; PointingOn and DetumblingOff &lt; DetumblingOn to avoid frequent toggling.</p>"},{"location":"adcs/#simulation-progress-and-analysis","title":"Simulation Progress and Analysis","text":"<p>In a standard situation simulation starts with higher angular velocity reduced by detumbling, then pointing (B-cross) and off state alternate. If pointing causes excessive spin-up, detumbling restarts. Full cycle typically in several to tens of thousands of iterations. Pointing not fully finished and stable; unpredictable behavior may occur. Besides confirming some initial parameters the terminal usually shows only mode change info and iteration timer. While adding logs is convenient for temporary checks and development, to avoid clutter and simplify work without digging into functions, analysis tools were implemented: state vector and plotting.</p>"},{"location":"adcs/#state-vector","title":"State Vector","text":"<p>The state vector is a table containing all possible data describing satellite state at given times: angular velocity, position, magnetic field measurements, Sun vector, torque, etc. Class design allows adding any value at any time. If not measured or computed during an iteration empty entries are filled with NaN. Code below shows registering values:</p> <pre><code>satellite.state_vector.reset()  # without reset it would accumulate data from previous tests\nsatellite.state_vector.next_row()  # initialization and iterating row index\n\nsatellite._state_vector.register_vector(\"angular_velocity\", satellite.angular_velocity, labels=[\"x\", \"y\", \"z\"])\nsatellite._state_vector.register_value(\"latitude\", satellite.latitude)\n\nprint(satellite._state_vector.to_dataframe())\n</code></pre> <p>Output:</p> <pre><code>angular_velocity_x angular_velocity_y angular_velocity_z latitude\n0 2.0               -3.0               4.0                26.40241\n</code></pre> <p>If the first line satellite.state_vector.reset() is removed and code executed multiple times data begins accumulating. If a new parameter is registered mid-way earlier values are auto-filled:</p> <pre><code># satellite.state_vector.reset()\nsatellite.state_vector.next_row()\n\nsatellite._state_vector.register_vector(\"angular_velocity\", satellite.angular_velocity, labels=[\"x\", \"y\", \"z\"])\nsatellite._state_vector.register_value(\"latitude\", satellite.latitude)\nsatellite._state_vector.register_value(\"pointing_error\", satellite.pointing_error_angle)\n\nprint(satellite._state_vector.to_dataframe())\n</code></pre> <p>Example:</p> <pre><code>  angular_velocity_x angular_velocity_y angular_velocity_z latitude pointing_error\n0 2.0                -3.0               4.0                26.40241 NaN\n1 2.0                -3.0               4.0                26.40241 NaN\n2 2.0                -3.0               4.0                26.40241 NaN\n3 2.0                -3.0               4.0                26.40241 0.0\n4 2.0                -3.0               4.0                26.40241 0.0\n</code></pre> <p>To simplify basic table management utilities.py contains basic_state_vector() which records selected basic parameters each iteration. For full analysis save table to CSV:</p> <pre><code>satellite.state_vector.to_csv('simulation_state_vector.csv')\n</code></pre>"},{"location":"adcs/#plots","title":"Plots","text":"<p>Another helpful element: plots. Implemented in two variants. One uses matplotlib\u2014popular tool enabling creation of many data representations, styling, and saving as images. The second uses plotly\u2014a more advanced tool enabling interactive zoom and precise value readout in HTML or notebook window plus defining live plots (helpful during development). Both variants implemented similarly in visualizations.py as separate classes with templates for line, scatter, and 3D plots (orbit visualization). Using these templates ready functions for selected basic parameters were created. All collected in basic_plots() that generates and saves plots. Below example using templates:</p> <pre><code>from visualizations.visualizations import MatplotlibPlots\nfrom visualizations.visualizations import PlotlyPlots\nimport numpy as np\n\nx = np.arange(0, 10, 0.1)\ny = np.sin(x)\n\nmpl = MatplotlibPlots(save=False, show=True)\npp = PlotlyPlots(save=False, show=True)\n\nmpl.line_plot({\"Sine Wave\": (x, y)}, \"Sine Function\", \"X-axis\", \"sin(x)\", \"sine_wave_matplotlib\")\npp.line_plot({\"Sine Wave\": (x, y)}, \"Sine Function\", \"X-axis\", \"sin(x)\", \"sine_wave_plotly\")\n</code></pre> <p>This code should display two plots. Below how to add live plotting with plotly. Full example in notebook version. Add at start:</p> <pre><code>live_w = LivePlotlyLine(\n  labels=[\"wx\", \"wy\", \"wz\", \"|w|\"],\n  title=\"Angular velocity (live)\",\n  xlabel=\"Time (s)\",\n  ylabel=\"deg/s\",\n  window=1000,\n)\n</code></pre> <p>Update each iteration:</p> <pre><code>wx, wy, wz = map(float, satellite.angular_velocity)\nwmag = float(np.sqrt(wx*wx + wy*wy + wz*wz))\nlive_w.update(float(x), [wx, wy, wz, wmag])\n</code></pre> <p>Interactive plot shows below including defined number of points. Multiple live plots possible. For matplotlib plots a configuration class defines styling parameters.</p>"},{"location":"adcs/#tests","title":"Tests","text":"<p>Since this repository is more scientific-engineering in nature, tests are not implemented in classical production sense. Their goal is facilitating editing, confirming operation of certain code elements, and ensuring fragments return values in expected shape\u2014helpful for identifying potential errors introduced during editing. Run tests with:</p> <pre><code>pytest\n</code></pre> <p>Optionally clear terminal before running to improve readability.</p> <p>Additionally Jupyter Notebook examples.ipynb contains usage examples of fragments described in text; correct execution also helps during development.</p>"},{"location":"adcs/#summary","title":"Summary","text":"<p>The created code is a base for further modification and expansion of a simple ADCS system for a small satellite; modular architecture makes adding additional sensors (e.g. horizon sensor, star trackers, full IMU) and actuators (e.g. reaction wheels and hybrid electromagnetic coil) easier. Pointing mode (B\u2011cross) still requires refinement\u2014stability, gain tuning, and switching logic. You are encouraged to use, modify, and draw inspiration from this repository for your own projects. If you notice an error or have an improvement suggestion, feel free to get in touch.</p>"},{"location":"adcs/#materials","title":"Materials","text":"<p>Below are materials that were helpful at various stages of creating this simulation. Note that near some specific functions links to helpful resources directly related to them were added. This is not all used sources. For certain topics\u2014especially mathematics, transformations, or code\u2014forum threads proved invaluable. For strictly technical subjects English Wikipedia often offers good summaries. Language models (external chat and GitHub Copilot) were also used.</p> <p>https://www.aero.iitb.acs/satelliteWiki/index.php/Main_Page https://automaticaddison.com/extended-kalman-filter-ekf-with-python-code-example/ https://digitalcommons.usu.edu/smallsat/2019/all2019/49/ https://www.diva-portal.org/smash/get/diva2:1018210/FULLTEXT02.pdf https://docs.advancednavigation.com/gnss-compass/Foundation%20Knowledge.htm https://files.core.ac.uk/download/pdf/286701577.pdf https://www.gov.br/inpe/pt-br/area-conhecimento/unidade-nordeste/conasat/documentacja/nano-satelites-pelo-mundo/aausat-3-aalborg-university-denmark/aausat-3-adcs-attitudedeterminationandcontrolsystem.pdf https://magneticearth.org/pages/models.html https://medium.com/@sasha_przybylski/the-math-behind-extended-kalman-filtering-0df981a87453 https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/Tutorials/pdf/individual_docs/17_frames_and_coordinate_systems.pdf https://quaternions.online/ https://probablydance.com/2017/08/05/intuitive-quaternions/ https://www.3dgep.com/understanding-quaternions/</p>"},{"location":"adcs_pl/","title":"Wprowadzenie","text":"<p>Poni\u017cszy kod wykonuje symulacj\u0119 ADCS (Attitude Determination and Control System) dla ma\u0142ego satelity (CubeSat). Odtwarza otoczenie na zadanej orbicie, parametry obiektu i wyznacza jego orientacj\u0119 oraz dynamik\u0119 (pr\u0119dko\u015b\u0107 i przyspieszenie k\u0105towe). G\u0142\u00f3wne zadania to detumbling (B-dot) i pointing (B-cross). Zaimplementowano magnetometr, czujnik S\u0142o\u0144ca oraz algorytmy TRIAD, QUEST i EKF. Sterowanie realizuj\u0105 trzy cewki elektromagnetyczne.</p> <p>Symulacja sk\u0142ada si\u0119 z trzech g\u0142\u00f3wnych element\u00f3w:  - Odtworzenie warunk\u00f3w orbitalnych i \u015brodowiskowych, w tym pola grawitacyjnego Ziemi, oporu atmosferycznego, pola magnetycznego oraz po\u0142o\u017cenia S\u0142o\u0144ca.  - Okre\u015blenie orientacji i dynamiki satelity na podstawie pomiar\u00f3w z czujnik\u00f3w (magnetometr, czujnik S\u0142o\u0144ca) oraz algorytm\u00f3w fuzji danych (TRIAD, QUEST, EKF).  - Sterowanie satelit\u0105 w celu realizacji zada\u0144 detumblingu (wyhamowywania obrot\u00f3w) i pointingu (ukierunkowania na Ziemi\u0119 lub S\u0142o\u0144ce) przy u\u017cyciu cewek elektromagnetycznych.</p>"},{"location":"adcs_pl/#przygotowanie","title":"Przygotowanie","text":""},{"location":"adcs_pl/#instalacja","title":"Instalacja","text":"<p>Ca\u0142o\u015b\u0107 kodu stworzona jest w Pythonie i wykorzystuje dedykowane biblioteki zar\u00f3wno do operacji matematycznych, jak i implementowania podstawowych modeli astronomicznych. Dalsza cz\u0119\u015b\u0107 zak\u0142ada posiadanie zainstalowanego Pythona (preferowany 3.13). \u015arodowisko zarz\u0105dzane jest przy pomocy Poetry. Zwi\u0119z\u0142\u0105 instrukcj\u0119 dotycz\u0105c\u0105 instalacji mo\u017cna znale\u017a\u0107 w ich dokumentacji (https://python-poetry.org/docs/). Jednym z podstawowych element\u00f3w projektu Poetry jest plik pyproject.toml znajduj\u0105cy si\u0119 w g\u0142\u00f3wnym folderze repozytorium. Definiuje on wymagane biblioteki oraz ich wersje. Co istotne, aby uzyska\u0107 pewno\u015b\u0107 kompatybilno\u015bci i dzia\u0142ania, wersje bibliotek zosta\u0142y zablokowane.</p> <p>Aby zbudowa\u0107 \u015brodowisko nale\u017cy wykona\u0107 nast\u0119puj\u0105c\u0105 komend\u0119:</p> <pre><code>poetry install\n</code></pre> <p>Skorzysta\u0107 ze \u015brodowiska mo\u017cna w r\u00f3\u017cnoraki spos\u00f3b. - Wywo\u0142uj\u0105c poetry bezpo\u015brednio (zalecane):</p> <pre><code>poetry run python adcs.py\n</code></pre> <ul> <li>Uruchamiaj\u0105c \u015brodowisko w terminalu:</li> </ul> <pre><code>poetry env activate  # zwr\u00f3ci spersonalizowan\u0105 komend\u0119 do uruchomienia \u015brodowiska\n# przyk\u0142ad aktywacji \u015brodowiska (PowerShell):\n&amp; \"C:\\sciezka\\do\\env\\Scripts\\Activate.ps1\"\npython adcs.py\ndeactivate\n</code></pre> <ul> <li>Wybieraj\u0105c stworzone \u015brodowisko w edytorze kodu. Taki krok konieczny jest cho\u0107by w celu skorzystania z Jupyter Notebook.</li> </ul>"},{"location":"adcs_pl/#struktura-projektu","title":"Struktura projektu","text":"<pre><code>ADCS/\n\u251c\u2500 adcs.py\n\u251c\u2500 mkdocs.yml\n\u251c\u2500 pyproject.toml\n\u251c\u2500 docs/\n\u2502  \u251c\u2500 index.md\n\u2502  \u251c\u2500 adcs.md\n\u2502  \u2514\u2500 adcs_pl.md\n\u251c\u2500 core/\n\u2502  \u251c\u2500 logger.py\n\u2502  \u251c\u2500 state.py\n\u2502  \u251c\u2500 transformations.py\n\u2502  \u2514\u2500 utilities.py\n\u251c\u2500 spacecraft/\n\u2502  \u251c\u2500 actuator.py\n\u2502  \u251c\u2500 sensors.py\n\u2502  \u2514\u2500 satellite.py\n\u251c\u2500 setup/\n\u2502  \u251c\u2500 initial_settings.py\n\u2502  \u251c\u2500 initial_settings.json\n\u2502  \u251c\u2500 two_line_element.py\n\u2502  \u2514\u2500 tle\n\u251c\u2500 templates/\n\u2502  \u251c\u2500 actuator_template.py\n\u2502  \u251c\u2500 sensor_template.py\n\u2502  \u251c\u2500 satellite_template.py\n\u2502  \u251c\u2500 two_line_element_template.py\n\u2502  \u2514\u2500 initial_settings_template.py\n\u251c\u2500 visualizations/\n\u2502  \u2514\u2500 visualizations.py\n\u2514\u2500 tests/\n   \u251c\u2500 conftest.py\n   \u251c\u2500 test_actuator.py\n   \u251c\u2500 test_sensors.py\n   \u2514\u2500 test_transformations.py\n</code></pre> <p>Podstaw\u0105 projektu jest folder spacecraft, gdzie umieszczone s\u0105 podstawowe cz\u0119\u015bci kodu odpowiadaj\u0105ce za systemy satelity. - Skrypt satellite.py odpowiada za generalne zarz\u0105dzanie i sterowanie poszczeg\u00f3lnymi elementami, spinaj\u0105c ca\u0142o\u015b\u0107 w jeden obiekt, przy pomocy kt\u00f3rego mo\u017cna zarz\u0105dza\u0107 najwa\u017cniejszymi parametrami satelity. - Skrypt sensors.py odpowiada za ca\u0142o\u015b\u0107 kodu zwi\u0105zanego z pomiarami, zar\u00f3wno cz\u0119\u015b\u0107 symuluj\u0105c\u0105 \u015brodowisko do pomiaru, zaszumienie i przetwarzanie poszczeg\u00f3lnymi algorytmi (TRIAD, QUEST, EKF). - Skrypt actuator.py odpowiada z kolei za elementy czynne (w tym wypadku jedynie cewki elektromagnetyczne). Jego rol\u0105 jest implementacja algorytm\u00f3w kontroli (detumbling i pointing) oraz zarz\u0105dzanie dzia\u0142aniem zgodnie ze spodziewanym efektem.</p> <p>Folder core zawiera funkcje pomocne w pracy, g\u0142\u00f3wnie zwi\u0105zane z operacjami matematycznymi czy szeroko poj\u0119t\u0105 orientacj\u0105 przestrzenn\u0105 i jej przetwarzaniem. - Skrypt logger.py zawiera zdefiniowany modu\u0142 do wy\u015bwietlania. - Skrypt state.py odpowiada za zarz\u0105dzanie wektorem stanu. - Skrypt transformations.py skupia si\u0119 na funkcjach zwi\u0105zanych z orientacj\u0105, takich jak przej\u015bcia mi\u0119dzy uk\u0142adami wsp\u00f3\u0142rz\u0119dnych, operacje na kwaternionach i obroty. - Skrypt utilities.py zawiera wszelkie pozosta\u0142e przydatne funkcje, jak zmiana formatu daty.</p> <p>W folderze setup zebrane s\u0105 informacje dotycz\u0105ce ustawie\u0144 symulacji, danych wej\u015bciowych oraz skrypty odpowiedzialne za ich przetwarzanie. - Plik tle zgodnie z nazw\u0105 zawiera TLE (Two-Line Element Set) opisuj\u0105cy parametry orbitalne satelity. - Skrypt two_line_element.py odpowiada za jego wczytywanie i intuicyjne wyci\u0105ganie zawartych w nim parametr\u00f3w. - Plik initial_settings.json jest zbiorem parametr\u00f3w i ustawie\u0144 odpowiadaj\u0105cych za stan pocz\u0105tkowy, warto\u015bci sta\u0142ych, parametry satelity czy wykorzystywane tryby. Z jego poziomu mo\u017cna zarz\u0105dza\u0107 wi\u0119kszo\u015bci\u0105 zmiennych maj\u0105cych wp\u0142yw na przebieg symulacji. - Skrypt initial_settings.py odpowiada za wczytywanie i zarz\u0105dzanie ustawieniami zawartymi w initial_settings.json.</p> <p>Folder visualizations zwi\u0105zany jest z wykresami pozwalaj\u0105cymi sprawdzi\u0107 przebieg symulacji. - Skrypt visualizations.py zawiera kod odpowiedzialny za tworzenie wykres\u00f3w.</p> <p>W folderze templates zdefiniowane s\u0105 pliki, kt\u00f3re stanowi\u0105 szkielet opisuj\u0105cy podstawow\u0105 zawarto\u015b\u0107 najwa\u017cniejszych element\u00f3w repozytorium. Zawarte w nich parametry s\u0105 niezb\u0119dnymi elementami w\u0142a\u015bciwych skrypt\u00f3w.</p>"},{"location":"adcs_pl/#pierwsze-uruchomienie","title":"Pierwsze uruchomienie","text":"<p>Uruchomienie mo\u017ce odby\u0107 si\u0119 na dwa sposoby. Po zbudowaniu \u015brodowiska mo\u017cliwe jest albo wykonanie skryptu adcs.py, kt\u00f3ry zawiera zintegrowan\u0105 symulacj\u0119, lub notatnikiem Jupyter Notebook. W tym przypadku kod wykona si\u0119 dla domy\u015blnych ustawie\u0144 i powinien zwr\u00f3ci\u0107 normalne logi.</p> <pre><code>2025-11-14 23:42:20 | INFO | Simulation initialized with the following parameters:\n2025-11-14 23:42:20 | INFO | Number of iterations: 10000\n2025-11-14 23:42:20 | INFO | Satellite mass: 1.2 kg\n2025-11-14 23:42:20 | INFO | Satellite inertia: [[0.002 0.    0.   ]\n [0.    0.002 0.   ]\n [0.    0.    0.002]] kg*m^2\n2025-11-14 23:42:20 | INFO | Initial angular velocity: [ 2. -3.  4.] deg/s\n2025-11-14 23:42:20 | INFO | Initial attitude (Euler angles): [0. 0. 0.] deg\n2025-11-14 23:42:20 | INFO | Selected sensor fusion algorithm: EKF\n2025-11-14 23:42:20 | INFO | Magnetometer noise: 10.0 nT\n2025-11-14 23:42:20 | INFO | Sunsensor noise: 0.2 deg\n2025-11-14 23:42:20 | INFO | Sensor on time: 2 seconds, actuator on time: 8 seconds\n\n2025-11-14 23:42:20 | INFO | Iteration 0 of 10000\n2025-11-14 23:42:25 | INFO | Iteration 100 of 10000\n</code></pre> <p>Taka forma oznacza, \u017ce kod dzia\u0142a poprawnie.</p>"},{"location":"adcs_pl/#podstawy","title":"Podstawy","text":"<p>Poni\u017cej w skr\u00f3cie przedstawione zosta\u0142y najwa\u017cniejsze zagadnienia teoretyczne wraz z przyk\u0142adami zastosowania i odniesienia do zastosowa\u0144 w kodzie symulacji. Jako \u017ce niekt\u00f3re funkcje i metody zosta\u0142y przygotowane konkretnie do dzia\u0142ania w ramach repozytorium, ich poprawne funkcjonowanie wymaga inicjalizacji podstawowych obiekt\u00f3w i parametr\u00f3w. Mo\u017ce to by\u0107 wykonane poni\u017cszym fragmentem kodu (w wi\u0119kszo\u015bci przypadk\u00f3w ten fragment b\u0119dzie umieszczony na pocz\u0105tku):</p> <pre><code>from pathlib import Path\nfrom spacecraft.satellite import SatelliteImplementation\nfrom setup.initial_settings import SimulationSetupReader\nfrom setup.two_line_element import TwoLineElementReader\nfrom spacecraft.sensors import MagnetometerImplementation, SunsensorImplementation, SensorFusionImplementation\n\nsetup = SimulationSetupReader(Path('setup/initial_settings.json'))\ntle = TwoLineElementReader(Path('setup/tle'))\nmagnetometer = MagnetometerImplementation(setup)\nsunsensor = SunsensorImplementation(setup)\nsensor_fusion = SensorFusionImplementation(setup, ['triad', 'quest', 'ekf'], tr.euler_xyz_to_quaternion(setup.euler_angles))\n\nsatellite = SatelliteImplementation(setup, tle, magnetometer, sunsensor, sensor_fusion)\n</code></pre>"},{"location":"adcs_pl/#orbita-i-otoczenie","title":"Orbita i otoczenie","text":""},{"location":"adcs_pl/#data-julianska-jd-julian-date","title":"Data julia\u0144ska (JD - Julian Date)","text":"<p>Data julia\u0144ska jest cz\u0119sto wykorzystywan\u0105 form\u0105 przedstawienia czasu w obliczeniach i algorytmach astronomicznych. Jest to u\u0142amek przedstawiaj\u0105cy liczb\u0119 dni od 1 stycznia 4713 r. p.n.e. godziny 12. Na przyk\u0142ad dla daty w formacie UTC 2025-10-18 00:00:00.000 JD wyniesie 2460966.5. Czasem spotka\u0107 mo\u017cna format Zmodyfikowanej Daty Julia\u0144skiej (MJD - Modified Julian Date), kt\u00f3ra ma na celu uproszczenie przedstawionego u\u0142amka i liczona jest jako MJD = JD - 2400000.5. Dla powy\u017cszego przyk\u0142adu b\u0119dzie to 60966. W kodzie zastosowana jest standardowa JD, kt\u00f3ra wykorzystywana jest w bibliotece Skyfield. Wchodzi jako argument do modelu propagatora i pozwala uzyska\u0107 parametry orbitalne satelity. Za przekszta\u0142cenie odpowiada funkcja, kt\u00f3ra zwraca aktualny czas satelity (czas pocz\u0105tku symulacji plus liczba iteracji). Dla domy\u015blnych ustawie\u0144 bior\u0105cych aktualny czas jako start b\u0119dziemy mieli:</p> <pre><code>import core.utilities as ut\n\ntime_satellite = satellite.setup.date_time\nsatellite_julian_date = ut.time_julian_date(satellite)\n\nprint(f\"Satellite time: {time_satellite}\")\nprint(f\"Satellite Julian date: {satellite_julian_date}\")\n</code></pre> <p>Powy\u017cszy fragment powinien zwr\u00f3ci\u0107 przyk\u0142adowo:</p> <pre><code>Satellite time: 2025-10-22 13:25:41.386584\nSatellite Julian date: &lt;Time tt=2460818.709556771&gt;\n</code></pre> <p>Uwaga: Skyfield prezentuje czas w skali TT (Terrestrial Time). R\u00f3\u017cni si\u0119 ona od UTC o \u0394T (sekundy przest\u0119pne i dryf). Dla potrzeb IGRF wp\u0142yw jest pomijalny, ale dla precyzyjnych konwersji czasowych nale\u017cy uwzgl\u0119dnia\u0107 TT\u2194UTC.</p>"},{"location":"adcs_pl/#tle","title":"TLE","text":"<p>Najpopularniejszym formatem zapisu parametr\u00f3w obiekt\u00f3w na orbitach oko\u0142oziemskich jest TLE (Two-Line Element Set), kt\u00f3ry zgodnie z nazw\u0105 sk\u0142ada si\u0119 z dw\u00f3ch linii, gdzie ka\u017cda seria znak\u00f3w ma swoje konkretne znaczenie. Przyk\u0142adowy zapis umieszczony i wykorzystywany w tym repozytorium przedstawiono poni\u017cej (mo\u017cna go r\u00f3wnie\u017c znale\u017a\u0107 pod \u015bcie\u017ck\u0105 ADCS/setup/tle):</p> <pre><code>1 25544U 98067A 25143.20875603 .00008836 00000-0 16445-3 0 9994\n2 25544 51.6382 70.8210 0002488 135.0606 10.4960 15.49676890511280\n</code></pre> <p>Aby prosto wczytywa\u0107 i wyci\u0105ga\u0107 dane z zapisu TLE stworzono odpowiadaj\u0105cy za czytanie kod (two_line_element.py). Pozwala on zar\u00f3wno wyci\u0105ga\u0107 poszczeg\u00f3lne elementy, znaj\u0105c ich nazwy, jak i podawa\u0107 ca\u0142e linie pliku w formie str. Znaczenie serii znak\u00f3w zosta\u0142o pokr\u00f3tce dodane do opis\u00f3w funkcji. Dobre podsumowanie i rozpisk\u0119 formatu mo\u017cna znale\u017a\u0107 na Wikipedii (https://en.wikipedia.org/wiki/Two-line_element_set).</p> <p>Wystarczy zainicjalizowa\u0107 TLE, aby m\u00f3c z niego skorzysta\u0107:</p> <pre><code>print(f'Two Line Element:\\n{tle.line_1}\\n{tle.line_2}')\n\nprint(f\"Epoch Year: {tle.epoch_year}\")\nprint(f\"Epoch Day: {tle.epoch_day}\")\n\nprint(f\"Inclination: {tle.inclination}\")\nprint(f\"Bstar Drag: {tle.bstar_drag}\")\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>Two Line Element:\n1 25544U 98067A 25143.20875603 .00008836 00000-0 16445-3 0 9994\n2 25544 51.6382 70.8210 0002488 135.0606 10.4960 15.49676890511280\nEpoch Year: 25\nEpoch Day: 143.20875603\nInclination: 51.6382\nBstar Drag: 16445-3\n</code></pre> <p>Warto zwr\u00f3ci\u0107 uwag\u0119 na format zapisu, Bstar Drag w TLE zapisane jako \u201e16445-3\u201d nale\u017cy interpretowa\u0107 jako 0.16445e-3 (tj. 1.6445e-4).</p>"},{"location":"adcs_pl/#propagator","title":"Propagator","text":"<p>Propagator orbitalny wyznacza po\u0142o\u017cenie satelity, jej pr\u0119dko\u015b\u0107 i przyspieszenie w danym momencie. W tej symulacji u\u017cyto SGP4 (Simplified General Perturbations 4). Korzysta z danych TLE i wymaga ich okresowej aktualizacji, aby ograniczy\u0107 narastanie b\u0142\u0119d\u00f3w. Implementacja pochodzi z biblioteki Skyfield.</p> <pre><code>import skyfield.api as skyfield\n\nsatellite_model = skyfield.EarthSatellite(tle.line_1, tle.line_2)\njulian_date = ut.time_julian_date(satellite)\n\nposition = satellite_model.at(julian_date).position.km\nvelocity = satellite_model.at(julian_date).velocity.km_per_s\n\nprint(f\"Position vector: {position} [km]\")\nprint(f\"Velocity vector: {velocity} [km/s]\")\n</code></pre> <p>Zgodnie z powy\u017cszym przyk\u0142adem kod powinien zwr\u00f3ci\u0107:</p> <pre><code>Position vector: [-4107.48809952 -4489.58941621  3014.80595056] [km]\nVelocity vector: [ 2.23875988 -5.3942253  -4.96501356] [km/s]\n</code></pre> <p>Po\u0142o\u017cenie i pr\u0119dko\u015b\u0107 s\u0105 podstawowymi wynikami, ale mo\u017cliwe jest te\u017c uzyskanie wysoko\u015bci nad elipsoid\u0105 (WGS\u201184), d\u0142ugo\u015bci i szeroko\u015bci geograficznej. Warto zauwa\u017cy\u0107, \u017ce wyniki Skyfield s\u0105 w uk\u0142adzie GCRS (inercjalny, zgodny z ICRF przy J2000); \u201eECI\u201d jest u\u017cywane skr\u00f3towo jako nazwa zbiorcza. Je\u015bli wykorzystywany jest bezpo\u015brednio SGP4/TEME, do ECEF/ITRF potrzebna jest transformacja (precesja, nutacja, czas gwiazdowy).</p> <p>Nieco wi\u0119cej mo\u017cna znale\u017a\u0107 pod linkiem https://www.aero.iitb.ac.in/satelliteWiki/index.php/Orbit_Propagator</p>"},{"location":"adcs_pl/#niska-orbita-okooziemska-leo-low-earth-orbit","title":"Niska orbita oko\u0142oziemska (LEO - Low Earth Orbit)","text":"<p>Cz\u0119\u015b\u0107 kosmosu, kt\u00f3ra rozci\u0105ga si\u0119 od Ziemi a\u017c do pas\u00f3w Van Allena, okre\u015bla si\u0119 jako nisk\u0105 orbit\u0119 oko\u0142oziemsk\u0105. W praktyce m\u00f3wi si\u0119 o pu\u0142apie od oko\u0142o 200 km do 2000 km. Jest ona szczeg\u00f3lnie popularna ze wzgl\u0119du na swoj\u0105 blisko\u015b\u0107 i zwi\u0105zany z tym niski koszt wynoszenia. Jest to jednak r\u00f3wnocze\u015bnie problem ze wzgl\u0119du na wci\u0105\u017c wyst\u0119puj\u0105cy op\u00f3r atmosferycznego (szczeg\u00f3lnie istotny dla pu\u0142apu do 300 km) oraz ograniczone pole widzenia. Z punktu widzenia uk\u0142adu okre\u015blania orientacji i sterowania blisko\u015b\u0107 do Ziemi ma jeszcze jedn\u0105 istotn\u0105 zalet\u0119, czyli stosunkowo silne pole magnetyczne, kt\u00f3re mo\u017ce by\u0107 wykorzystywane w czujnikach i elementach czynnych.</p>"},{"location":"adcs_pl/#ziemskie-pole-magnetyczne","title":"Ziemskie pole magnetyczne","text":"<p>Ziemia wytwarza naturalnie pole magnetyczne wewn\u0105trz i w swoim otoczeniu. Jego kszta\u0142t w przybli\u017ceniu odpowiada dipolowi lekko odchylonemu od osi obrotu. Sk\u0142ada si\u0119 ze sk\u0142adowej sta\u0142ej i zmiennej (ta druga to typowo 1-5%). Wyst\u0119puj\u0105 te\u017c lokalne anomalie. Dzi\u0119ki obserwacjom opracowano dok\u0142adne modele, m.in. IGRF. W tej symulacji u\u017cyto biblioteki pyIGRF. Aby z niego skorzysta\u0107, potrzebne s\u0105 wsp\u00f3\u0142rz\u0119dne geograficzne oraz data w formie u\u0142amka dziesi\u0119tnego (czas od pocz\u0105tku roku przedstawiony jako u\u0142amek, np. 2024.25 jako pierwszy kwarta\u0142 danego roku).</p> <pre><code>import pyIGRF\nimport core.utilities as ut\nimport datetime\n\nlat = satellite.latitude\nlon = satellite.longitude\nalt_km = satellite.altitude\njulian_date = ut.time_julian_date(satellite)\n\ndt = julian_date.utc_datetime()\nstart = datetime.datetime(dt.year, 1, 1, tzinfo=dt.tzinfo)\nend = datetime.datetime(dt.year + 1, 1, 1, tzinfo=dt.tzinfo)\ndecimal_year = dt.year + (dt - start).total_seconds() / (end - start).total_seconds()\n\n# IGRF returns NED components in nT\nd, i, h, b_n, b_e, b_d, f = pyIGRF.igrf_value(lat, lon, alt_km, decimal_year)\n\nprint(f\"IGRF Magnetic Field NED: B_n={b_n:.2f}, B_e={b_e:.2f}, B_d={b_d:.2f} [nT]\")\nprint(f\"IGRF Magnetic Field Magnitude: F={f:.2f} [nT]\")\nprint(f\"IGRF Declination: D={d:.2f} [deg], Inclination: i={i:.2f} [deg], Horizontal Intensity: H={h:.2f} [nT]\")\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>IGRF Magnetic Field NED: B_n=20470.13, B_e=-760.77, B_d=29507.77 [nT]\nIGRF Magnetic Field Magnitude: F=35920.94 [nT]\nIGRF Declination: D=-2.13 [deg], Inclination: i=55.23 [deg], Horizontal Intensity: H=20484.26 [nT]\n</code></pre> <p>Biblioteka domy\u015blnie zwraca wektor i wypadkow\u0105 warto\u015b\u0107 pola, deklinacj\u0119, inklinacj\u0119 oraz intensywno\u015b\u0107 horyzontaln\u0105. Z punktu widzenia ADCS istotny jest jedynie wektor. Warto zwr\u00f3ci\u0107 uwag\u0119, \u017ce akurat pyIGRF zwraca go w formacie NED (North-East-Down) i przed dalsz\u0105 prac\u0105 nale\u017cy go podda\u0107 odpowiednim transformacjom (patrz rozdzia\u0142 o transformacjach).</p> <p>Wi\u0119cej informacji o modelu IGRF mo\u017cna znale\u017a\u0107 tutaj https://geomag.bgs.ac.uk/research/modelling/IGRF</p>"},{"location":"adcs_pl/#pozycja-sonca","title":"Pozycja S\u0142o\u0144ca","text":"<p>S\u0142o\u0144ce i jego po\u0142o\u017cenie to kolejny istotny element pomocny w okre\u015bleniu orientacji w przestrzeni kosmicznej z racji jego dobrze przewidywalnego po\u0142o\u017cenia wzgl\u0119dem Ziemi. Bior\u0105c pod uwag\u0119 ogromn\u0105 odleg\u0142o\u015b\u0107, kt\u00f3ra dzieli oba cia\u0142a niebieskie, dla prostych oblicze\u0144 na niskiej orbicie mo\u017cna przyj\u0105\u0107 opis z perspektywy planety, pomijaj\u0105c ruch orbitalny satelity. Dobry opis, jak obliczy\u0107 krok po kroku pozycj\u0119 S\u0142o\u0144ca, mo\u017cna znale\u017a\u0107 ponownie na Wikipedii: https://en.wikipedia.org/wiki/Position_of_the_Sun</p> <p>W tym przypadku u\u017cyto Skyfield do obliczenia wektora S\u0142o\u0144ca wzgl\u0119dem Ziemi dla zadanej daty julia\u0144skiej.</p> <pre><code>import skyfield.api as skyfield\nimport core.utilities as ut\n\n# load ephemeris data for sun and earth\neph = skyfield.load('de421.bsp')\nsun = eph['sun']\nearth = eph['earth']\n\njulian_date = ut.time_julian_date(satellite)\n\nsun_position_eci = earth.at(julian_date).observe(sun).position.km\n\nprint(f\"Sun Position ECI: {sun_position_eci} [km]\")\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>Sun Position ECI: [7.11550861e+07 1.22678186e+08 5.31785009e+07] [km]\n</code></pre> <p>Zwr\u00f3cony wektor S\u0142o\u0144ca jest w uk\u0142adzie ICRF (dla uproszcze\u0144 traktowany jako \u201eECI\u201d).</p>"},{"location":"adcs_pl/#orientacja-i-transformacje","title":"Orientacja i transformacje","text":""},{"location":"adcs_pl/#ukady-odniesienia","title":"Uk\u0142ady odniesienia","text":"<p>Aby wyznaczy\u0107 orientacj\u0119 przestrzenn\u0105, nale\u017cy najpierw ustali\u0107 uk\u0142ad wsp\u00f3\u0142rz\u0119dnych. Ze wzgl\u0119du na r\u00f3\u017cnorodno\u015b\u0107 obiekt\u00f3w i zastosowa\u0144 w przestrzeni kosmicznej stosowany jest ca\u0142y szereg r\u00f3\u017cnych uk\u0142ad\u00f3w. Poni\u017cej om\u00f3wiono kilka, kt\u00f3re przewijaj\u0105 si\u0119 w tym repozytorium.</p> <ul> <li> <p>Uk\u0142ad Satelity (Satellite Body - SB) - jest to uk\u0142ad na sta\u0142e zwi\u0105zany ze statkiem kosmicznym, a wi\u0119c poruszaj\u0105cy i obracaj\u0105cy si\u0119 razem z nim po orbicie. W przypadku uproszczonej symulacji ma\u0142ego obiektu b\u0119dzie on powi\u0105zany z czujnikami i to w\u0142a\u015bnie w nim podawane b\u0119d\u0105 symulowane pomiary. W praktyce jednak definiuje si\u0119 tzw. baz\u0119 nawigacyjn\u0105 w pewnym punkcie satelity, a czasem czujniki mog\u0105 mie\u0107 w\u0142asne uk\u0142ady odniesienia.</p> </li> <li> <p>Ziemski uk\u0142ad inercjalny (Earth-Centered Inertial - ECI) - uk\u0142ad zwi\u0105zany z Ziemi\u0105, ale zablokowany wzgl\u0119dem gwiazd. O\u015b Z w kierunku bieguna p\u00f3\u0142nocnego, o\u015b X wzd\u0142u\u017c przeci\u0119cia r\u00f3wnika i ekliptyki, o\u015b Y dope\u0142niaj\u0105ca. Pocz\u0105tek w \u015brodku masy Ziemi. W praktyce cz\u0119sto u\u017cywa si\u0119 GCRS (zgodny z ICRF).</p> </li> <li> <p>Ziemski uk\u0142ad zwi\u0105zany (Earth-Centered Earth-Fixed - ECEF) - uk\u0142ad obracaj\u0105cy si\u0119 z Ziemi\u0105. O\u015b Z wzd\u0142u\u017c osi obrotu Ziemi, o\u015b X to przeci\u0119ciecie r\u00f3wnika i po\u0142udnika 0\u00b0, o\u015b Y r\u00f3wnika i po\u0142udnika 90\u00b0E.</p> </li> <li> <p>East-North-Up / North-East-Down (ENU / NED) - s\u0105 to dwie wariacje uk\u0142adu wsp\u00f3\u0142rz\u0119dnych przydatnego do opisywania obiekt\u00f3w w okolicy Ziemi. Dwie peirwsze osie (X i Y) s\u0105 zorientowane zgodnie z kierunkiem p\u00f3\u0142nocnym lub wschodnim, a zasadnicz\u0105 r\u00f3\u017cnic\u0105 mi\u0119dzy nimi jest o\u015b Z, kt\u00f3ra mo\u017ce by\u0107 zwr\u00f3cona w kierunku \u015brodka Ziemi lub przeciwnym (ENU: x=East, y=North, z=Up. NED: x=North, y=East, z=Down). Ten uk\u0142ad r\u00f3wnie\u017c mo\u017ce si\u0119 pojawi\u0107 w kontek\u015bcie pola magnetyczego (modele IGRF zwracaj\u0105 warto\u015bci w tym uk\u0142adzie).</p> </li> <li> <p>International Celestial Reference Frame (ICRF - International Celestial Reference Frame) - inercjalny uk\u0142ad odniesienia z pocz\u0105tkiem w barycentrum Uk\u0142adu S\u0142onecznego; w praktyce u\u017cywany do efemeryd. Dla orbit oko\u0142ozimskich traktowany jako \u201eECI\u201d.</p> </li> <li> <p>Longitude / Latitude / Altitude (LLA - d\u0142ugo\u015b\u0107, szeroko\u015b\u0107, wysoko\u015b\u0107 nad elipsoid\u0105) - forma geodezyjna wzgl\u0119dem WGS\u201184.</p> </li> </ul>"},{"location":"adcs_pl/#przedstawienie-orientacji-i-rotacji","title":"Przedstawienie orientacji i rotacji","text":"<p>W przypadku uk\u0142adu ADCS dla satelity na niskiej orbicie oko\u0142oziemskiej najwa\u017cniejszymi uk\u0142adami b\u0119d\u0105 ECI i SBF, gdzie pierwszy jest punktem odniesienia, a drugi zwi\u0105zany jest z pomiarami wykonywanymi na satelicie. Przej\u015bcie mi\u0119dzy nimi b\u0119dzie sk\u0142ada\u0142o si\u0119 z translacji (przesuni\u0119cia) i rotacji. Pierwszy z tych dw\u00f3ch element\u00f3w zapewnia propagator, zwracaj\u0105c po\u0142o\u017cenie satelity w danym momencie. Natomiast znalezienie odpowiedniej rotacji, kt\u00f3ra r\u00f3wnocze\u015bnie b\u0119dzie oznacza\u0142a orientacj\u0119 przestrzenn\u0105 satelity, jest zadaniem uk\u0142adu ADCS osi\u0105ganym na podstawie wykonywania pomiar\u00f3w czujnikami i por\u00f3wnywania ich z referencj\u0105. Przedstawienie orientacji i rotacji mo\u017ce odby\u0107 si\u0119 na kilka sposob\u00f3w:</p> <ul> <li>K\u0105ty Eulera - czyli trzy kolejne rotacje wzgl\u0119dem wybranych osi uk\u0142adu. Cho\u0107 jest to do\u015b\u0107 intuzyjny spos\u00f3b, ch\u0119tnie wykorzystywany cho\u0107by w lotnictwie, posiada swoje ograniczenia czyni\u0105ce go mniej u\u017cytecznym w kosmosie np. blokada przegubu (gimbal lock). W kodzie u\u017cywane do inicjalizacji i wizualizacji.</li> <li>Kwaternion - q = [u_x sin(\u03b1/2), u_y sin(\u03b1/2), u_z sin(\u03b1/2), cos(\u03b1/2)]. Czteroelementowe przedstawienie rotacji, sk\u0142adaj\u0105ce si\u0119 z cz\u0119\u015bci wektorowej i skalarnej. Cz\u0119\u015b\u0107 wektorowa odpowiada osi obrotu u, a cz\u0119\u015b\u0107 skalarna to cos(\u03b1/2). Kwaternion jest zwi\u0119z\u0142\u0105, wygodn\u0105 i stabiln\u0105 numerycznie reprezentacj\u0105 rotacji, pozbawion\u0105 wad k\u0105t\u00f3w Eulera. </li> <li>Macierz rotacji - najbardziej podstawowa forma przedstawienia to macierz, kt\u00f3r\u0105 powinno si\u0119 pomno\u017cy\u0107 pierwotny wektor, aby otrzyma\u0107 wektor docelowy.</li> </ul> <p>Tematyka rotacji potrafi by\u0107 podchwytliwa i generowa\u0107 b\u0142\u0119dy, aby zminimalizowa\u0107 ich ryzyko, do wi\u0119kszo\u015bci operacji wykorzystywana jest sprawdzona biblioteka scipy, kt\u00f3ra obs\u0142uguje wszystkie najwa\u017cniejsze funkcje. Poni\u017cej przedstawiono przyk\u0142ad obejmuj\u0105cy prost\u0105 rotacj\u0119 w formie k\u0105t\u00f3w Eulera oraz kwaternionu przy pomocy wspomnianej biblioteki.</p> <pre><code>import scipy.spatial.transform as R\n\neuler_angles_init = [90.0, 0.0, 0.0]  # degrees\nquaternion_init = [0.70710678, 0.0, 0.0, 0.70710678]  # [x, y, z, w]\n\nreproduced_quaternion = R.Rotation.from_euler('xyz', euler_angles_init, degrees=True).as_quat()\nreproduced_euler_angles = R.Rotation.from_quat(quaternion_init).as_euler('xyz', degrees=True)\n\nprint(f\"Initial Euler Angles: {euler_angles_init} [deg]\")\nprint(f\"Initial Quaternion: {quaternion_init} [x, y, z, w]\")\nprint(f\"Reproduced Quaternion from Euler Angles: {reproduced_quaternion} [x, y, z, w]\")\nprint(f\"Reproduced Euler Angles from Quaternion: {reproduced_euler_angles} [deg]\")\n\nv1 = [0.0, 1.0, 0.0]\n\nrotation = R.Rotation.from_quat(quaternion_init)\nv2 = rotation.apply(v1)\n\nprint(f\"Original Vector: {v1}\")\nprint(f\"Rotated Vector: {v2}\")\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>Initial Euler Angles: [90.0, 0.0, 0.0] [deg]\nInitial Quaternion: [0.70710678 0.         0.         0.70710678] [x, y, z, w]\nReproduced Quaternion from Euler Angles: [0.70710678 0.         0.         0.70710678] [x, y, z, w]\nReproduced Euler Angles from Quaternion: [90.  0.  0.] [deg]\nOriginal Vector: [0.0, 1.0, 0.0]\nRotated Vector: [0. 0. 1.]\n</code></pre> <p>Uwaga: po ka\u017cdej aktualizacji kwaternion powinien by\u0107 normalizowany, aby ograniczy\u0107 dryf numeryczny.</p> <p>W podobny spos\u00f3b stworzono funkcje do przechodzenia pomi\u0119dzy uk\u0142adami wsp\u00f3\u0142rz\u0119dnymi, kt\u00f3re mo\u017cna znale\u017a\u0107 w core/transformations.py. Poni\u017cej przedstawiono u\u017cycie pi\u0119ciu podstawowych, zaimplementowanych przej\u015b\u0107:</p> <pre><code>import core.transformations as tr\nimport core.utilities as ut\n\nv1 = [0.0, 1.0, 0.0]\njulian_date = ut.time_julian_date(satellite)\nquaternion_init = [0.70710678, 0.0, 0.0, 0.70710678]\n\nenu_ecef = tr.enu_to_ecef(v1, satellite.latitude, satellite.longitude)\nned_ecef = tr.ned_to_ecef(v1, satellite.latitude, satellite.longitude)\necef_eci = tr.ecef_to_eci(v1, julian_date)\neci_sbf = tr.eci_to_sbf(v1, quaternion_init)\nsbf_eci = tr.sbf_to_eci(v1, quaternion_init)\n\nprint(f\"Original Vector: {v1}\")\nprint(f\"ENU to ECEF: {enu_ecef}\")\nprint(f\"NED to ECEF: {ned_ecef}\")\nprint(f\"ECEF to ECI: {ecef_eci}\")\nprint(f\"ECI to SBF: {eci_sbf}\")\nprint(f\"SBF to ECI: {sbf_eci}\")\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>Original Vector: [0.0, 1.0, 0.0]\nENU to ECEF: [ 0.02791803  0.44449952 -0.89534393]\nNED to ECEF: [ 0.99961022 -0.01241439  0.02500598]\nECEF to ECI: [0.69189531 0.72199784 0.        ]\nECI to SBF: [0. 0. 1.]\nSBF to ECI: [ 0.  0. -1.]\n</code></pre>"},{"location":"adcs_pl/#czujniki-i-elementy-czynne","title":"Czujniki i elementy czynne","text":""},{"location":"adcs_pl/#magnetometry","title":"Magnetometry","text":"<p>Magnetometr jest urz\u0105dzeniem pozwalaj\u0105cym na pomiar pola magnetycznego. Istnieje wiele rodzaj\u00f3w magnetometr\u00f3w o r\u00f3\u017cnych mo\u017cliwo\u015bciach i rozmiarach w zale\u017cno\u015bci od zastosowania i charakteru misji. W przypadku niewielkich satelit\u00f3w na niskiej orbicie stosowane s\u0105 magnetometry trzyosiowe. Cz\u0119sto s\u0105 magnetometry to transduktorowe, dzia\u0142aj\u0105ce w oparciu o nasycenie rdzenia magnetycznego lub dzia\u0142aj\u0105ce na zasadzie magnetorezystancji. Dzi\u0119ki post\u0119puj\u0105cej miniaturyzacji s\u0105 to cz\u0119sto niewielkie, lekkie uk\u0142ady o ma\u0142ym poborze mocy.</p> <p>W przypadku tej symulacji magnetometr wybrany jako g\u0142\u00f3wny czujnik. Symulacja magnetometr\u00f3w opiera si\u0119 o pole magnetyczne uzyskane przy pomocy modelu IGRF (International Geomagnetic Reference Field - IGRF). Aby uzyska\u0107 warto\u015b\u0107 b\u0119d\u0105c\u0105 odpowiednikiem faktycznego pomiaru wykonanego przez przyrz\u0105dy pok\u0142adowe, wektor musi zosta\u0107 przekszta\u0142cony do uk\u0142adu SBF. Mo\u017cliwe jest r\u00f3wnie\u017c dodanie szumu, w tym przypadku opartego o maksymaln\u0105 bezwzgl\u0119dn\u0105 odchy\u0142k\u0119.</p> <pre><code>mag_field_sbf += noise_vector\n</code></pre> <p>gdzie noise_vector = &lt;-x: +x&gt;.</p> <p>Ustawienia dotycz\u0105ce szum\u00f3w mo\u017cna znale\u017a\u0107 w initial_settings.json:</p> <pre><code>\"Magnetometer\":\n{\n  \"Noise\": true,\n  \"AbsoluteNoise\": 10,\n  \"UnitInfo\": \"nT\"\n},\n</code></pre> <p>Model szumu jest uproszony (jednakowa, jednostajna odchy\u0142ka \u00b1A na ka\u017cdej osi). W rzeczywistych czujnikach cz\u0119\u015bciej spotka si\u0119 rozk\u0142ad Gaussa + zak\u0142ocenia + dryf.</p>"},{"location":"adcs_pl/#czujnik-sonca","title":"Czujnik S\u0142o\u0144ca","text":"<p>Czujniki S\u0142o\u0144ca umo\u017cliwiaj\u0105 okre\u015blenie tzw. wektora S\u0142o\u0144ca, czyli kierunku, w kt\u00f3rym znajduje si\u0119 S\u0142o\u0144ce wzgl\u0119dem satelity. W zale\u017cno\u015bci od roli pomiaru w systemie mog\u0105 to by\u0107 bardzo dok\u0142adne czujniki matrycowe lub nieco mniej dok\u0142adne, oparte o uk\u0142ady kilku fotodiod rozmieszczonych na zewn\u0119trznych panelach. To w\u0142a\u015bnie ten drugi najcz\u0119\u015bciej spotka\u0107 mo\u017cna na ma\u0142ych satelitach. Dzi\u0119ki swojej prostocie stanowi\u0105 one bardzo dobre uzupe\u0142nienie dla pozosta\u0142ych czujnik\u00f3w. W tym przypadku traktowany jest on z regu\u0142y jako drugi czujnik.</p> <p>Wzgl\u0119dne po\u0142o\u017cenie S\u0142o\u0144ca uzyskiwane jest poprzez model obserwacji w bibliotece Skyfield (co opisano wcze\u015bniej), a nast\u0119pnie transformowane jest do uk\u0142adu SB. W ten spos\u00f3b uzyskiwany jest odpowiedni wektor w formie, w jakiej by\u0142by odczytany za pomoc\u0105 czujnik\u00f3w satelity. Nast\u0119pnie mo\u017ce on zosta\u0107 zaszumiony. Szum czujnika S\u0142o\u0144ca realizowany jest jako obr\u00f3t wektora wok\u00f3\u0142 losowej osi o losowym k\u0105cie z zadanego zakresu.</p> <pre><code>sun_vector = raw_sun_vector * R\n</code></pre> <p>gdzie R to macierz rotacji reprezentuj\u0105ca obr\u00f3t o k\u0105t z zakresu &lt;-x: +x&gt;.</p> <p>Ustawienia dotycz\u0105ce szum\u00f3w znajduj\u0105 si\u0119 w initial_settings.json:</p> <pre><code>\"SunSensor\":\n{\n  \"Noise\": true,\n  \"AngularNoise\": 0.2,\n  \"UnitInfo\": \"deg\"\n},\n</code></pre>"},{"location":"adcs_pl/#zyroskopy","title":"\u017byroskopy","text":"<p>\u017byroskop to rodzaj czujnika, kt\u00f3ry mierzy pr\u0119dko\u015b\u0107 k\u0105tow\u0105 bezpo\u015brednio (nie przyspieszenie k\u0105towe). W klasycznym uj\u0119ciu jest to du\u017ce, wiruj\u0105ce urz\u0105dzenie mechaniczne wykorzystuj\u0105ce zasad\u0119 zachowania momentu p\u0119du. W praktyce misji kosmicznych zazwyczaj wykorzystuje si\u0119 uk\u0142ady MEMS (Micro-Electromechanical Systems), czyli urz\u0105dzenia oparte o niewielkie drgaj\u0105ce elementy, kt\u00f3re pozwalaj\u0105 zmierzy\u0107 pr\u0119dko\u015bci obrotowe w oparciu o si\u0142\u0119 Coriolisa. S\u0105 to niewielkie i tanie uk\u0142ady, jednak ich wadami s\u0105 ograniczona dok\u0142adno\u015b\u0107 i narastaj\u0105cy z biegiem czasu dryf. W przypadku tej symulacji pr\u0119dko\u015b\u0107 k\u0105towa mo\u017ce by\u0107 wyznaczana z r\u00f3\u017cnicy orientacji mi\u0119dzy iteracjami: nale\u017cy dzieli\u0107 przez \u0394t i najlepiej u\u017cy\u0107 pochodnej kwaternionu (\u03c9 = 2 q\u0307 \u2297 q\u207b\u00b9). Dryf nie jest szczeg\u00f3\u0142owo modelowany.</p> <pre><code>\"Gyroscope\":\n{\n  \"Bias\": [0.0, 0.0, 0.0],\n  \"ProcessNoise\": [1e-8, 1e-8, 1e-8],\n  \"UnitInfo\": \"deg/s\"\n},\n</code></pre>"},{"location":"adcs_pl/#fuzja-sensorow","title":"Fuzja sensor\u00f3w","text":"<p>Jednym z podstawowych problem\u00f3w zwi\u0105zanych z okre\u015blaniem orientacji przestrzennej jest \u0142\u0105czenie pomiar\u00f3w z dw\u00f3ch i wi\u0119cej \u017ar\u00f3de\u0142 w taki spos\u00f3b, aby uzyska\u0107 jedn\u0105, bardziej niezawodn\u0105 i dok\u0142adniejsz\u0105 estymat\u0119. Wykorzystanie kilku rodzaj\u00f3w czujnik\u00f3w pozwala na zbilansowanie potencjalnych problem\u00f3w w sytuacjach, gdzie jeden poradzi\u0142by sobie gorzej. Aby uzyska\u0107 sprawnie przetworzony pomiar, tworzone s\u0105 specjalne algorytmy. W przypadku misji kosmicznych cz\u0119sto wyr\u00f3\u017cnia si\u0119 trzy z nich:</p> <ul> <li> <p>TRIAD (Three-Axis Attitude Determination) - jest najbardziej podstawowym i najprostszym z nich. Umo\u017cliwia przetworzenie pomiar\u00f3w jedynie z dw\u00f3ch czujnik\u00f3w, znaj\u0105c wektory w uk\u0142adzie satelity i ich odpowiedniki w uk\u0142adzie odniesienia. Odnajdywanie macierzy rotacji mi\u0119dzy nimi odbywa si\u0119 poprzez tworzenie tzw. triad (uk\u0142ady odniesienia bazuj\u0105ce na danych wektorach) i wzajemnego po\u0142o\u017cenia mi\u0119dzy nimi.</p> </li> <li> <p>QUEST (QUaternion ESTimator) - jest algorytmem odnajdywania rotacji dla serii wektor\u00f3w (QUEST mo\u017ce przetworzy\u0107 dwa czujniki i wi\u0119cej, w odr\u00f3\u017cnieniu od TRIAD-a) poprzez minimalizacj\u0119 funkcji b\u0142\u0119du (problem Wahby). Wynikiem jego dzia\u0142ania jest bezpo\u015brednio kwaternion przedstawiaj\u0105cy rotacj\u0119, kt\u00f3ry odpowiada wektorowi w\u0142asnemu (eigenvector) macierzy skonstruowanej z danych pomiarowych. Opcjonalnie pomiary mog\u0105 by\u0107 zaopatrzone w wagi, definiuj\u0105c najbardziej dok\u0142adne z nich.</p> </li> <li> <p>EKF (Extended Kalman Filter) - jest bardziej zaawansowanym algorytmem estymacji stanu dla r\u00f3wna\u0144 nieliniowych. Opiera si\u0119 na dzia\u0142aniu iteracyjnym, z jednej strony wykorzystuj\u0105c model dynamiki obiektu, aby przewidywa\u0107 jego przysz\u0142y stan, z drugiej korzysta z pomiar\u00f3w czujnik\u00f3w do jego korekcji. W przypadku uk\u0142adu ADCS b\u0119dzie wi\u0119c wykorzystywa\u0142 nie tylko pary wektor\u00f3w pomiar\u00f3w, ale r\u00f3wnie\u017c pr\u0119dko\u015b\u0107 k\u0105tow\u0105 oraz poprzedni\u0105 orientacj\u0119. Estymaty wyliczane przy pomocy EKF powinny by\u0107 zauwa\u017calnie dok\u0142adniejsze od TRIAD-a i QUEST-a. Poni\u017cej przedstawiono przyk\u0142ad wykorzystania algorytm\u00f3w do uzyskania kwaternionu dla uk\u0142adu dw\u00f3ch wektor\u00f3w obr\u00f3conych o 90 stopni przy zerowej pr\u0119dko\u015bci k\u0105towej.</p> </li> </ul> <pre><code>import numpy as np\n\n# two reference vectors\nv1_i = np.array([1.0, 0.0, 0.0])\nv2_i = np.array([0.70710678, 0.70710678, 0.0])\n\n# two measured vectors with some noise rotated by 90 deg around z axis\nv1_b = np.array([0.0, 1.0, 0.0]) + np.random.uniform(-0.02, 0.02, size=3)\nv2_b = np.array([-0.70710678, 0.70710678, 0.0]) + np.random.uniform(-0.05, 0.05, size=3)\n\nq_reference = np.array([0.0, 0.0, 0.70710678, 0.70710678])\n\n# typically the first vector should be the most accurate one\nv_i_list = [v1_i, v2_i]\nv_b_list = [v1_b, v2_b]\n\n# normalize before estimation (TRIAD/QUEST/EKF)\nv_i_list = [v/np.linalg.norm(v) for v in v_i_list]\nv_b_list = [v/np.linalg.norm(v) for v in v_b_list]\n\nq_triad = sensor_fusion.triad(v_b_list, v_i_list)\nq_quest = sensor_fusion.quest(v_b_list, v_i_list)\nq_ekf = sensor_fusion.ekf(v_b_list, v_i_list, np.array([0.0, 0.0, 0.0, 0.0]), 1, q_reference)\n\n# signs may differ between algorithms, but represent the same rotation q = -q\nprint(f\"Reference quaternion: {q_reference} [x, y, z, w]\")\nprint(f\"TRIAD Quaternion: {q_triad} [x, y, z, w]\")\nprint(f\"QUEST Quaternion: {q_quest} [x, y, z, w]\")\nprint(f\"EKF Quaternion: {q_ekf} [x, y, z, w]\")\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>Reference quaternion: [0.         0.         0.70710678 0.70710678] [x, y, z, w]\nTRIAD Quaternion: [-0.01693025 -0.01254686  0.7105929   0.70328776] [x, y, z, w]\nQUEST Quaternion: [-0.01691007 -0.01257405  0.70946175  0.70442883] [x, y, z, w]\nEKF Quaternion: [-0.00855144 -0.00616122  0.70900606  0.70512362] [x, y, z, w]\n</code></pre> <p>Wida\u0107, \u017ce estymata zapewniona przez QUEST jest nieco lepsza ni\u017c TRIAD, jednak to EKF najbli\u017cszy jest warto\u015bci prawdziwej (wynik b\u0119dzie r\u00f3\u017cni\u0142 si\u0119 przy ka\u017cdym uruchomieniu ze wzgl\u0119du na losowe szumy). Wyb\u00f3r algorytmu do fuzji sensor\u00f3w oraz parametry jego uruchomienia ustalane s\u0105 z poziomu initial_settings.json (jedynie TRIAD nie posiada dodatkowych parametr\u00f3w).</p>"},{"location":"adcs_pl/#cewki-elektromagnetyczne","title":"Cewki elektromagnetyczne","text":"<p>Tak jak rol\u0105 sensor\u00f3w jest zapewnienie niezawodnej informacji o dynamice i orientacji satelity, tak rol\u0105 element\u00f3w czynnych jest wykorzystanie tej informacji w celu zapewnienia sterowania zgodnie z ustalonym profilem. Cewki elektromagnetyczne s\u0105 podstawowym elementem sterowania dla ma\u0142ych satelit\u00f3w na niskich orbitach oko\u0142oziemskich. Najcz\u0119\u015bciej wyst\u0119puj\u0105 w formie trzyosiowego uk\u0142adu cewek na rdzeniu magnetycznym lub na rdzeniu powietrznym. Ta druga forma jest cz\u0119sto stosowana ze wzgl\u0119du na lepsz\u0105 mo\u017cliwo\u015b\u0107 wpasowania w konstrukcj\u0119 satelity i taki uk\u0142ad za\u0142o\u017cono w projekcie.</p> <p>Podstaw\u0105 dzia\u0142ania jest generowanie przez cewk\u0119, przez kt\u00f3r\u0105 p\u0142ynie pr\u0105d, momentu magnetycznego. Oddzia\u0142uj\u0105c z ziemskim polem magnetycznym, b\u0119dzie on generowa\u0142 moment obrotowy zgodnie ze wzorem:</p> <pre><code>\u03c4 = m \u00d7 B\n</code></pre> <p>Jednostki: m [A\u00b7m\u00b2], B [T], \u03c4 [N\u00b7m]. </p> <p>Sterowanie jest ograniczone lokalnie s\u0142abym polem oraz geometri\u0105: gdy wymagany moment jest r\u00f3wnoleg\u0142y do B, m \u00d7 B \u2248 0 i sterowanie staje si\u0119 nieefektywne.</p> <p>Parametry cewki zastosowanej w projekcie mo\u017cna znale\u017a\u0107 w initial_settings.json:</p> <pre><code>\"Magnetorquer\": {\n  \"Coils\": 200,\n  \"MaxCurrent\": 0.2,\n  \"CoilArea\": 90,\n  \"SafetyFactor\": 0.9,\n  \"AlphaCap\": 0.5,\n  \"UnitInfo\": \"coils, cm^2, A, unitless, deg/s2\"\n}\n</code></pre> <p>Uwaga: CoilArea jest w cm\u00b2 i w obliczeniach przeliczana na m\u00b2 (\u00d71e\u20114).</p>"},{"location":"adcs_pl/#symulacja","title":"Symulacja","text":"<p>Powy\u017csze elementy sk\u0142adowe tworz\u0105 model, kt\u00f3ry umo\u017cliwia symulowanie niewielkiego satelity na orbitach oko\u0142oziemskich.</p>"},{"location":"adcs_pl/#ustawienia-wejsciowe","title":"Ustawienia wej\u015bciowe","text":"<p>W celu u\u0142atwienia zarz\u0105dzania wszelkimi parametrami maj\u0105cymi wp\u0142yw na przebieg symulacji zosta\u0142y one umieszczone w pliku json, a do jego zarz\u0105dzania stworzony zosta\u0142 kod initial_settings.py. Dzi\u0119ki temu mo\u017cliwe jest zarz\u0105dzanie ka\u017cdym etapem bez potrzeby zb\u0119dnego wchodzenia w odpowiadaj\u0105cy mu kod. Mo\u017cliwe jest te\u017c tworzenie kilku wariant\u00f3w uruchomienia, jako \u017ce plik json podawany jest jako parametr wej\u015bciowy w formie \u015bcie\u017cki, a nie jest zapisany na sztywno. Ca\u0142o\u015b\u0107 pogrupowana jest w strukturze przypominaj\u0105cej s\u0142ownik w Pythonie z pi\u0119cioma kluczami na g\u0142\u00f3wnym poziomie i kolejnymi bardziej szczeg\u00f3\u0142owymi. Do tego dodany jest wpis z jednostkami parametr\u00f3w, nie jest on nigdzie wczytywany i ma charakter informacyjny.</p> <ul> <li> <p>Simulation - zawiera podstawowe parametry dotycz\u0105ce samej symulacji, takie jak sta\u0142e fizyczne, zarz\u0105dzanie krokami symulacji czy dat\u0119 startu.</p> </li> <li> <p>Satellite - zawiera wszelkie parametry opisuj\u0105ce bezpo\u015brednio satelit\u0119, jak masa, inercja i pocz\u0105tkowe ustawienie.</p> </li> <li> <p>Sensors - zawiera wszelkie istotne parametry zwi\u0105zane z sensorami i wykonywaniem pomiar\u00f3w. B\u0119d\u0105 wi\u0119c to nastawy samych czujnik\u00f3w, ale te\u017c parametry algorytmu fuzji sensor\u00f3w.</p> </li> <li> <p>Actuators - zawiera parametry dotycz\u0105ce element\u00f3w czynnych, w tym wypadku b\u0119d\u0105 to jedynie parametry cewki elektromagnetycznej, takie jak liczba zwoj\u00f3w, pole przekroju, wsp\u00f3\u0142czynnik bezpiecze\u0144stwa, ograniczenie przyspieszenia.</p> </li> <li> <p>Controls - zawiera wszelkie parametry zwi\u0105zane ze sterowaniem satelit\u0105, takie jak wyb\u00f3r algorytmu fuzji sensor\u00f3w, ustawienia i parametry zwi\u0105zane z algorytmami detumblingu i pointingu czy prze\u0142\u0105czania tryb\u00f3w.</p> </li> </ul> <p>Skrypt initial_settings.py przygotowany jest do sprawnego dzia\u0142ania z aktualnie zastan\u0105 struktur\u0105 wpis\u00f3w. Brak kt\u00f3regokolwiek z wymaganych kluczy spowoduje pojawienie si\u0119 b\u0142\u0119du, jednak mo\u017cliwe jest dodanie dodatkowych wpis\u00f3w. Je\u015bli takowy pojawi si\u0119 na najni\u017cszym poziomie, po prostu zostanie dodany do wczytanej struktury. Dodanie jednostki jest opcjonalne. Na przyk\u0142ad:</p> <pre><code>\"Magnetorquer\":\n{\n  \"Coils\": 200,\n  \"MaxCurrent\": 0.2,\n  \"CoilArea\": 90,\n  \"SafetyFactor\": 0.9,\n  \"AlphaCap\": 0.5,\n  \"WireDia\": 0.8,\n  \"UnitInfo\": \"coils, cm^2, A, unitless, deg/s2, mm\"\n}\n</code></pre> <p>Wtedy w zdefiniowanym w skrypcie s\u0142owniku pojawi si\u0119 on jako klucz:</p> <pre><code>setup.magnetorquer_params[\"WireDia\"]\n</code></pre> <p>Natomiast je\u015bli dodany zostanie wpis w jakimkolwiek innym miejscu, trafi on do \"pozosta\u0142ych\" parametr\u00f3w zapisanych w self.other_parameters:</p> <pre><code>{\n  \"Simulation\": { \"PlanetConst\": ... },\n  \"SomeOtherData\": {\n    \"A\": 2,\n    \"B\": 4\n  }\n}\n</code></pre> <p>Wtedy ca\u0142o\u015b\u0107 zostanie wczytana w dok\u0142adnie takiej samej formie:</p> <pre><code>data_dict = setup.other_parameters[\"SomeOtherData\"]\nA = data_dict[\"A\"]\nB = data_dict[\"B\"]\n</code></pre>"},{"location":"adcs_pl/#parametry-satelity","title":"Parametry satelity","text":"<p>Aby u\u0142atwi\u0107 przeprowadzanie operacji zwi\u0105zanych z satelit\u0105, traktowany jest on jako obiekt sk\u0142adaj\u0105cy si\u0119 z pewnych komponent\u00f3w, a opisuj\u0105ce go najwa\u017cniejsze parametry zosta\u0142y okre\u015blone jako property w ramach satellite.py. Warto zwr\u00f3ci\u0107 uwag\u0119 na sam\u0105 inicjalizacj\u0119:</p> <pre><code>satellite = SatelliteImplementation(setup, tle, magnetometer, sunsensor, sensor_fusion)\n</code></pre> <p>A wi\u0119c elementami sk\u0142adowymi wp\u0142ywaj\u0105cymi na stan satelity s\u0105 dane wej\u015bciowe, TLE, dwa czujniki: magnetometr i czujnik s\u0142o\u0144ca oraz algorytm fuzji. Mo\u017cliwe jest proste dostanie si\u0119 zar\u00f3wno do sta\u0142ych parametr\u00f3w, jak i na bie\u017c\u0105co aktualizowanych tych, kt\u00f3re okre\u015blaj\u0105 aktualny stan. Dzi\u0119ki ich wcze\u015bniejszemu zdefiniowaniu pojawiaj\u0105 si\u0119 one jako \"podpowiedzi\" w edytorze oraz mo\u017cliwe jest szybkie wy\u015bwietlenie ich opisu. Przyk\u0142adowe parametry przedstwiono poni\u017cej:</p> <pre><code>print(satellite.angular_velocity)\nprint(satellite.inertia_matrix)\nprint(satellite.magnetic_field)\nprint(satellite.torque)\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>[  8. -14.  11.]\n[[0.002 0.    0.   ]\n [0.    0.002 0.   ]\n [0.    0.    0.002]] (array([-12117.938582  , -12371.50694404, -31464.45657624]), array([-12121.11401262, -12375.32291477, -31468.13563725]))\n[0. 0. 0.]\n</code></pre>"},{"location":"adcs_pl/#algorytmy","title":"Algorytmy","text":"<p>Podstaw\u0105 zachowania satelity na orbicie s\u0105 zaimplementowane algorytmy sterowania. Ich definicja zwi\u0105zana jest z charakterem misji, dost\u0119pnymi czujnikami czy elementami czynnymi. Podstawowe trzy stany, z jakimi mo\u017cna spotka\u0107 si\u0119 w przypadku satelit\u00f3w, to detumbling (wyhamowywanie obrot\u00f3w), pointing (skierowanie na cel) oraz stan wy\u0142\u0105czony. Przej\u015bcia mi\u0119dzy nimi zdefiniowane s\u0105 przez osi\u0105gni\u0119cie pewnych kryteri\u00f3w i znale\u017a\u0107 je mo\u017cna w initial_settings.json.</p>"},{"location":"adcs_pl/#detumbling-wytracanie-obrotow-b-dot","title":"Detumbling (wytracanie obrot\u00f3w) (B-dot)","text":"<p>Wyhamowywanie pr\u0119dko\u015bci obrotowej jest z regu\u0142y pierwszym i najwa\u017cniejszym zadaniem dla uk\u0142adu sterowania. Wypuszczony na orbit\u0119 satelita najcz\u0119\u015bciej trafia na orbit\u0119, obracaj\u0105c si\u0119 stosunkowo szybko i niekontrolowanie. Aby przej\u015b\u0107 do poprawnego wykonywania misji, nale\u017cy jego pozycj\u0119 przestrzenn\u0105 ustabilizowa\u0107 poprzez spowolnienie do pewnej warto\u015bci granicznej pr\u0119dko\u015bci. Doprowadzenie i utrzymanie odpowiednio niskich obrot\u00f3w to zadanie detumblingu. Dla za\u0142o\u017conego w projekcie wykorzystania do sterowania jedynie cewki elektromagnetycznej realizowane b\u0119dzie to algorytmem zwanym B-dot. Jego nazwa i zasada dzia\u0142ania odnosz\u0105 si\u0119 do pochodnej pola magnetycznego. Szybko\u015b\u0107 zmiany zmierzonego pola magnetycznego b\u0119dzie proporcjonalna do pr\u0119dko\u015bci k\u0105towej wzgl\u0119dem na ka\u017cdej osi. W praktyce generowany moment magnetyczny musi oddzia\u0142ywa\u0107 o przeciwnym zwrocie i zosta\u0107 odpowiednio powi\u0119kszony o wsp\u00f3\u0142czynnik wzmocnienia.</p> <pre><code>m = -k * dB/dt\n</code></pre> <p>Istnieje kilka modyfikacji podstawowego algorytmu, kt\u00f3re mog\u0105 okaza\u0107 si\u0119 przydatne w pewnych sytuacjach i zastosowaniach. Dla przyk\u0142adowego satelity 1U nie b\u0119d\u0105 to jednak r\u00f3\u017cnice wielkie. Poni\u017cej kr\u00f3tko om\u00f3wione zosta\u0142y pozosta\u0142e warianty:</p> <ul> <li>Zmodyfikowany B-dot - jego dzia\u0142anie nie bazuje na pochodnej pola magnetycznego, a bezpo\u015brednio na pomiarach pr\u0119dko\u015bci obrotowej. Jego dzia\u0142anie b\u0119dzie wi\u0119c mniej podatne na zak\u0142\u00f3cenia samego pola magnetycznego, ale wymaga odpowiedniego \u017ar\u00f3d\u0142a pomiar\u00f3w pr\u0119dko\u015bci k\u0105towej.</li> </ul> <pre><code>m = -k (\u03c9 \u00d7 B)\n</code></pre> <ul> <li>Proporcjonalny B-dot - do standardowego algorytmu dodany cz\u0142on t\u0142umi\u0105cy r\u00f3wnie\u017c oparty o pr\u0119dko\u015b\u0107 obrotow\u0105. Mo\u017ce mie\u0107 wp\u0142yw stabilizuj\u0105cy w obliczu zmian pola magnetycznego, ale je\u015bli b\u0119dzie zbyt mocny, sam b\u0119dzie powodowa\u0142 oscylacje lub nawet destabilizowa\u0142 kontroler przy ma\u0142ych pr\u0119dko\u015bciach obrotowych.</li> </ul> <pre><code>m = -k * dB/dt - k_p * \u03c9\n</code></pre> <ul> <li>Adaptuj\u0105cy pr\u0119dko\u015b\u0107 obrotow\u0105 - sama zasada dzia\u0142ania nie r\u00f3\u017cni si\u0119 od podstawowego wariantu, jednak wzmocnienie jest zale\u017cne od aktualnej pr\u0119dko\u015bci obrotowej wzgl\u0119dem pewnej ustalonej warto\u015bci granicznej. Powy\u017cej b\u0119dzie ono odpowiednio powi\u0119kszone, a poni\u017cej zmniejszone. Taki wariant przyspiesza pocz\u0105tkowe wytracanie pr\u0119dko\u015bci, za to mocno \u0142agodzi dzia\u0142ania kontrolera na p\u00f3\u017aniejszym etapie, mo\u017ce jednak utrudnia\u0107 t\u0142umienie przy bardzo ma\u0142ych pr\u0119dko\u015bciach.</li> </ul> <pre><code>k = k * (|\u03c9|/\u03c9_ref)^a\n</code></pre> <ul> <li>Adaptuj\u0105cy pole magnetyczne - r\u00f3wnie\u017c nie wp\u0142ywa na sam algorytm, a jedynie modyfikuje wzmocnienie. Jest ono zale\u017cne od warto\u015bci bezwzgl\u0119dnej pola magnetycznego w stosunku do pewnej warto\u015bci granicznej (cz\u0119sto przyjmowanej w okolicy \u015bredniej pola magnetycznego Ziemi ~45000 nT). Pomaga w ten spos\u00f3b niwelowa\u0107 wp\u0142yw zmian pola wraz z ruchem po orbicie, zwi\u0119kszaj\u0105c wzmocnienie, gdy te maleje, oraz zmniejszaj\u0105c, gdy jego warto\u015b\u0107 ro\u015bnie.</li> </ul> <pre><code>k = k * (B_ref/|B|)^b\n</code></pre> <p>Co istotne, powy\u017csze warianty mog\u0105 si\u0119 ze sob\u0105 \u0142\u0105czy\u0107. W wi\u0119kszo\u015bci przypadk\u00f3w jednak podstawowy B-dot b\u0119dzie wystarczaj\u0105cy. Algorytm jest bardzo prosty i niezawodny w swoim dzia\u0142aniu, dla niewielkiego satelity powinien sprawnie zbija\u0107 nawet bardzo du\u017ce pr\u0119dko\u015bci, a czas jego dzia\u0142ania powinien mie\u015bci\u0107 si\u0119 od nieca\u0142ej godziny do maksymalnie kilku (czasu symulacji) w zale\u017cno\u015bci od warunk\u00f3w pocz\u0105tkowych. Wynikowy wykres pr\u0119dko\u015bci obrotowej w czasie powinien g\u0142adko zbiega\u0107 do 0 in kszta\u0142cie przypominaj\u0105cym funkcj\u0119 1/x. Je\u015bli obserwowane s\u0105 oscylacje, zmiany kierunku pr\u0119dko\u015bci czy niestabilno\u015bci, nale\u017cy upewni\u0107 si\u0119 co do wybranych parametr\u00f3w.</p> <ul> <li> <p>Wzmocnienie - podstawowy parametr oddzia\u0142aj\u0105cy, kt\u00f3ry odpowiada za przekucie pochodnej na odpowiednio du\u017cy moment magnetyczny, kt\u00f3ry mo\u017ce by\u0107 obs\u0142u\u017cony przez cewki. Dla przyk\u0142adowego satelity 1U warto\u015bci mi\u0119dzy 1000 a 4000 powinny by\u0107 wystarczaj\u0105ce, dla wi\u0119kszych r\u00f3wnie\u017c wzmocnienie mo\u017cna odpowiednio zwi\u0119ksza\u0107. Wa\u017cnym parametrem, kt\u00f3ry nale\u017cy obserwowa\u0107 podczas doboru wzmocnienia, jest obci\u0105\u017cenie cewek, je\u015bli przez d\u0142ugi czas osi\u0105ga ono warto\u015bci maksymalne, wzmocnienie nale\u017cy zmniejszy\u0107. Analogicznie w drug\u0105 stron\u0119, gdy przez d\u0142ugi czas jest ono bardzo niskie, mo\u017cna je zwi\u0119kszy\u0107. Pomocniczym parametrem mo\u017ce te\u017c by\u0107 sam spadek pr\u0119dko\u015bci obrotowej - zbyt powolny mo\u017ce sugerowa\u0107 za ma\u0142e wzmocnienie.</p> </li> <li> <p>Wsp\u00f3\u0142czynnik proporcjonalny - pe\u0142ni raczej rol\u0119 pomocnicz\u0105, st\u0105d jego warto\u015b\u0107 te\u017c powinna by\u0107 odpowiednio ma\u0142a. Uwzgl\u0119dniaj\u0105c, \u017ce \u0142\u0105czony jest on bezpo\u015brednio z pr\u0119dko\u015bci\u0105 k\u0105tow\u0105 w radianach, mo\u017cna przyjmowa\u0107 warto\u015bci mi\u0119dzy 0.05 a 0.6.</p> </li> </ul> <p>Opr\u00f3cz tego nale\u017cy zwr\u00f3ci\u0107 uwag\u0119 na parametry satelity takie, jak masa i macierz inercji, oraz same parametry cewki elektromagnetycznej. Elementy te, cho\u0107 nie pojawiaj\u0105 si\u0119 w samym algorytmie, s\u0105 kluczowym elementem przetworzenia momentu magnetycznego na moment obrotowy.</p>"},{"location":"adcs_pl/#pointing-b-cross","title":"Pointing (B-cross)","text":"<p>UWAGA: Element ten wci\u0105\u017c jest w trakcie tworzenia i nie zachowuje si\u0119 stabilnie.</p> <p>Nakierowanie satelity konkretn\u0105 stron\u0105 w kierunku jakiego\u015b celu jest jedn\u0105 z podstawowych funkcji, kt\u00f3ra mo\u017ce by\u0107 realizowana w zwi\u0105zku z misj\u0105. Dla obiekt\u00f3w na orbitach oko\u0142oziemskich najcz\u0119\u015bciej b\u0119dzie to obr\u00f3t w kierunku Ziemi (np. nakierowanie kamery) lub w kierunku S\u0142o\u0144ca (np. optymalne ustawienie paneli s\u0142onecznych). Jednym z algorytm\u00f3w, kt\u00f3ry mo\u017cna zastosowa\u0107, wykorzystuj\u0105c cewki elektromagnetyczne, jest B-cross. Opiera si\u0119 on na zastosowaniu mno\u017cenia wektorowego (cross product) do minimalizacji k\u0105ta mi\u0119dzy dwoma danymi wektorami (cel i aktualne u\u0142o\u017cenie). W swojej podstawowej wersji algorytm ma posta\u0107 cz\u0142onu nakierowuj\u0105cego oraz t\u0142umi\u0105cego:</p> <pre><code>m = m_align + m_damp = k_a (error_vector \u00d7 B) + k_d (\u03c9 \u00d7 B)\n</code></pre> <p>Cz\u0119sto stosuje si\u0119 go w wersji znormalizowanej wzgl\u0119dem pola magnetycznego w celu poprawy stabilno\u015bci. Zmiana b\u0119dzie te\u017c przejawia\u0107 si\u0119 w rz\u0119dach wielko\u015bci wsp\u00f3\u0142czynnik\u00f3w wzmocnienia. Wtedy algorytm przybiera posta\u0107:</p> <pre><code>m = m_align + m_damp = k_a (error_vector \u00d7 B)/||B||^2 + k_d (\u03c9 \u00d7 B)/||B||^2\n</code></pre> <p>Wykorzystanie jedynie cewek niesie za sob\u0105 szereg trudno\u015bci, jak podatno\u015b\u0107 na lokalne zmiany pola magnetycznego czy niemo\u017cno\u015b\u0107 generowania momentu w sytuacjach, kiedy dany komponent pola jest r\u00f3wnoleg\u0142y. Do tego dochodzi trudno\u015b\u0107 w doborze optymalnych wsp\u00f3\u0142czynnik\u00f3w i precyzyjnym sterowaniu. To sprawia, \u017ce algorytm jest stosowany do wst\u0119pnego nakierowania lub jedynie zgrubnego pointingu.</p>"},{"location":"adcs_pl/#wyliczanie-przyspieszenia-katowego","title":"Wyliczanie przyspieszenia k\u0105towego","text":"<p>Wyznaczenie teoretycznego momentu magnetycznego generowanego przez cewki jest jedynie pierwszym krokiem do osi\u0105gni\u0119cia po\u017c\u0105danego przyspieszenia k\u0105towego. Pierwszym krokiem jest przeliczenie sk\u0142adowych na wymagane nat\u0119\u017cenie pr\u0105du w cewkach, uwzgl\u0119dniaj\u0105c liczb\u0119 zwoj\u00f3w i pole przekroju:</p> <pre><code>i = m / (n_coils * A_coil)\n</code></pre> <p>A jest w m\u00b2 (np. z RodArea_cm2 \u00d7 1e\u20114). W obliczeniach przyjmuje si\u0119, \u017ce moment obrotowy \u03c4 jest r\u00f3wny sumie momentu magnetycznego i moment\u00f3w zak\u0142\u00f3ce\u0144:</p> <pre><code>\u03c4_total = \u03c4_mag + \u03c4_bias\n\u03c4_mag = m \u00d7 B\n\u03b1 = I^{-1} ( \u03c4_total \u2212 \u03c9 \u00d7 (I \u03c9) )\n</code></pre> <p>gdzie:</p> <pre><code>coriolis = \u03c9 \u00d7 (I * w)\n</code></pre> <p>Do tak uzyskanego przyspieszenia mo\u017cna jeszcze zastosowa\u0107 ogranicznik, aby zniwelowa\u0107 destabilizacj\u0119 spowodowan\u0105 zbyt du\u017cymi i nag\u0142ymi skokami przyspieszenia. Wtedy skalowanie nale\u017cy zaaplikowa\u0107 r\u00f3wnie\u017c do nat\u0119\u017cenia pr\u0105du.</p>"},{"location":"adcs_pl/#przejscie-miedzy-trybami","title":"Przej\u015bcie mi\u0119dzy trybami","text":"<p>Ka\u017cdy z omawianych tryb\u00f3w ma swoje konkretnie okre\u015blone parametry rozpocz\u0119cia i zako\u0144czenia dzia\u0142ania. Przechodzenie mi\u0119dzy nimi odbywa si\u0119 na spos\u00f3b automatyczny i jest zdefiniowane w initial_settings.json:</p> <pre><code>\"ModeManagement\":\n{\n  \"DetumblingOff\": 0.5,\n  \"DetumblingOn\": 1.0,\n  \"PointingOff\": 10.0,\n  \"PointingOn\": 12.0,\n  \"PointingDwellTime\": 90,\n  \"UnitInfo\": \"deg/s, deg, deg, deg, s\"\n}\n</code></pre> <p>Dla detumblingu kluczowa jest pr\u0119dko\u015b\u0107 obrotowa, dla pointingu - utrzymywanie b\u0142\u0119du k\u0105ta w zakresie przez zadany czas (dwell). Progi maj\u0105 histerez\u0119: PointingOff &lt; PointingOn oraz DetumblingOff &lt; DetumblingOn, aby unikn\u0105\u0107 cz\u0119stego prze\u0142\u0105czania.</p>"},{"location":"adcs_pl/#przebieg-symulacji-i-analiza","title":"Przebieg symulacji i analiza","text":"<p>W standardowej sytuacji symulacja powinna zaczyna\u0107 si\u0119 od wi\u0119kszych pr\u0119dko\u015bci obrotowej, kt\u00f3re zostaj\u0105 zredukowane, a nast\u0119pnie uruchamia si\u0119 na zmian\u0119 pointing (B-cross) i stan wy\u0142\u0105czony. Je\u015bli w trakcie pointingu (B-cross) dojdzie do nadmiernego rozkr\u0119cenia satelity, detumbling uruchomi si\u0119 ponownie. Z regu\u0142y pe\u0142ny zakres czynno\u015bci powinien wykona\u0107 si\u0119 w trakcie od kilku do kilkunastu tysi\u0119cy iteracji. Niestety na ten moment pointing nie jest w pe\u0142ni sko\u0144czony i stabilny, st\u0105d towarzyszy\u0107 mu mog\u0105 nieprzewidywalne zachowania. Opr\u00f3cz potwierdzenia niekt\u00f3rych parametr\u00f3w pocz\u0105tkowych, standardowo w terminalu pojawia si\u0119 jedynie informacja o zmianie trybu oraz timer informuj\u0105cy o przeliczonej liczbie iteracji. Chocia\u017c dodawanie log\u00f3w jest sposobem wygodnym do tymczasowych sprawdze\u0144 i prac rozwojowych, aby nie za\u015bmieca\u0107 kodu i u\u0142atwi\u0107 prac\u0119 bez potrzeby rozgrzebywania poszczeg\u00f3lnych funkcji, zaimplementowano narz\u0119dzia do analizy. Jednym z nich jest wektor stanu, a drugim rozbudowane mo\u017cliwo\u015bci tworzenia wykres\u00f3w.</p>"},{"location":"adcs_pl/#wektor-stanu","title":"Wektor stanu","text":"<p>Jako wektor stanu okre\u015blana jest tabela zawieraj\u0105ca wszelkie mo\u017cliwe dane opisuj\u0105ce stan satelity w danych punktach czasu. Zawiera\u0107 b\u0119dzie wi\u0119c pr\u0119dko\u015b\u0107 k\u0105tow\u0105, pozycj\u0119, pomiary pola magnetycznego czy wektora s\u0142o\u0144ca, moment obrotowy itd. Sama klasa zosta\u0142a tak skonstruowana, aby mo\u017cliwe by\u0142o dodawanie dowolnej warto\u015bci w dowolnym momencie. Je\u015bli w danej iteracji nie b\u0119dzie ona mierzona lub wyliczana, puste miejsca zape\u0142nione b\u0119d\u0105 warto\u015bci\u0105 nan. Poni\u017cszy kod przedstawia mo\u017cliwo\u015bci zarejestrowania warto\u015bci w tabeli:</p> <pre><code>satellite.state_vector.reset()  # without reset it would accumulate data from previous tests\nsatellite.state_vector.next_row()  # initialization and iterating row index\n\nsatellite._state_vector.register_vector(\"angular_velocity\", satellite.angular_velocity, labels=[\"x\", \"y\", \"z\"])\nsatellite._state_vector.register_value(\"latitude\", satellite.latitude)\n\nprint(satellite._state_vector.to_dataframe())\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci:</p> <pre><code>angular_velocity_x angular_velocity_y angular_velocity_z latitude\n0 2.0               -3.0               4.0                26.40241\n</code></pre> <p>Je\u015bli usuniemy pierwsz\u0105 linijk\u0119 satellite.state_vector.reset() i wykonamy kolejne kilka linijek kilka razy, dane zaczn\u0105 si\u0119 akumulowa\u0107. Je\u015bli dodatkowo w trakcie zarejestrujemy nowy parametr, jego pocz\u0105tkowe warto\u015bci podlegn\u0105 autouzupe\u0142nianiu:</p> <pre><code># satellite.state_vector.reset()  # without reset it would accumulate data from previous tests\nsatellite.state_vector.next_row()  # initialization and iterating row index\n\nsatellite._state_vector.register_vector(\"angular_velocity\", satellite.angular_velocity, labels=[\"x\", \"y\", \"z\"])\nsatellite._state_vector.register_value(\"latitude\", satellite.latitude)\n# comment out satellite.state_vector.reset() and uncomment the line below to test accumulation\n# when some value is not present from the beginning\nsatellite._state_vector.register_value(\"pointing_error\", satellite.pointing_error_angle)\n\nprint(satellite._state_vector.to_dataframe())\n</code></pre> <p>Powy\u017cszy kod zwr\u00f3ci na przyk\u0142ad:</p> <pre><code>  angular_velocity_x angular_velocity_y angular_velocity_z latitude pointing_error\n0 2.0                -3.0               4.0                26.40241 NaN\n1 2.0                -3.0               4.0                26.40241 NaN\n2 2.0                -3.0               4.0                26.40241 NaN\n3 2.0                -3.0               4.0                26.40241 0.0\n4 2.0                -3.0               4.0                26.40241 0.0\n</code></pre> <p>W celu u\u0142atwienia podstawowego zarz\u0105dzania tabel\u0105 w utilities.py powsta\u0142a funkcja basic_state_vector(), kt\u00f3ra zapisuje wybrane, podstawowe parametry co iteracj\u0119. Aby dokona\u0107 pe\u0142nej analizy, po uruchomieniu mo\u017cna zapisa\u0107 tabel\u0119 do pliku csv:</p> <pre><code>satellite.state_vector.to_csv('simulation_state_vector.csv')\n</code></pre>"},{"location":"adcs_pl/#wykresy","title":"Wykresy","text":"<p>Kolejnym pomocnym elementem s\u0105 wykresy. W repozytorium zaimplementowano je w dw\u00f3ch wariantach. Jednym z nich jest wykorzystanie biblioteki matplotlib. Jest to jedno z najpopularniejszych narz\u0119dzi do tworzenia wykres\u00f3w. Daje mo\u017cliwo\u015b\u0107 tworzenia najr\u00f3\u017cniejszych przedstawie\u0144 danych i doboru stylistyki, a nast\u0119pnie zapisania ich w formie obrazu. Drugim jest plotly, kt\u00f3re jest narz\u0119dziem nieco bardziej zaawansowanym. Umo\u017cliwia tworzenie wykres\u00f3w z interaktywnym powi\u0119kszeniem i odczytem dok\u0142adnej warto\u015bci w formie html lub w okienku notebooka oraz zdefiniowanie wykres\u00f3w tworz\u0105cych si\u0119 na \u017cywo, co jest istotnym u\u0142atwieniem w trakcie prac rozwojowych. Oba warianty zosta\u0142y zaimplementowane w podobny spos\u00f3b w pliku visualizations.py jako osobne klasy. Maj\u0105 one zdefiniowane wzory do tworzenia wykres\u00f3w liniowych, punktowych czy tr\u00f3jwymiarowych (na u\u017cytek wizualizacji orbity). Z u\u017cyciem tych wzor\u00f3w stworzone zosta\u0142y gotowe funkcje dla wybranych, podstawowych parametr\u00f3w. Ca\u0142o\u015b\u0107 jest zebrana w funkcjach o nazwie basic_plots(), kt\u00f3ra tworzy i zapisuje na koniec te wykresy. Poni\u017cej przedstawiono mo\u017cliwo\u015b\u0107 wykorzystania zdefiniowanych wzor\u00f3w do stworzenia dowolnego wykresu:</p> <pre><code>from visualizations.visualizations import MatplotlibPlots\nfrom visualizations.visualizations import PlotlyPlots\nimport numpy as np\n\nx = np.arange(0, 10, 0.1)\ny = np.sin(x)\n\nmpl = MatplotlibPlots(save=False, show=True)\npp = PlotlyPlots(save=False, show=True)\n\nmpl.line_plot({\"Sine Wave\": (x, y)}, \"Sine Function\", \"X-axis\", \"sin(x)\", \"sine_wave_matplotlib\")\npp.line_plot({\"Sine Wave\": (x, y)}, \"Sine Function\", \"X-axis\", \"sin(x)\", \"sine_wave_plotly\")\n</code></pre> <p>Powy\u017cszy kod powinien skutkowa\u0107 wy\u015bwietleniem dw\u00f3ch wykres\u00f3w. Poni\u017cej natomiast przedstawiono, jak doda\u0107 wykonywanie wykres\u00f3w na bie\u017c\u0105co z wykorzystaniem plotly. Pe\u0142ny przyk\u0142ad mo\u017cna znale\u017a\u0107 w notatnikowej wersji symulacji. Poni\u017cszy kawa\u0142ek nale\u017cy doda\u0107 na pocz\u0105tku, aby zainicjalizowa\u0107 wykres:</p> <pre><code>live_w = LivePlotlyLine(\n  labels=[\"wx\", \"wy\", \"wz\", \"|w|\"],\n  title=\"Angular velocity (live)\",\n  xlabel=\"Time (s)\",\n  ylabel=\"deg/s\",\n  window=1000,  # rolling window in 'Time (s)' units\n)\n</code></pre> <p>Aby wykres na bie\u017c\u0105co si\u0119 aktualizowa\u0142 ju\u017c na etapie ka\u017cdej iteracji, nale\u017cy doda\u0107 nast\u0119puj\u0105cy kawa\u0142ek kodu:</p> <pre><code>wx, wy, wz = map(float, satellite.angular_velocity)\nwmag = float(np.sqrt(wx*wx + wy*wy + wz*wz))\nlive_w.update(float(x), [wx, wy, wz, wmag])\n</code></pre> <p>W ten spos\u00f3b poni\u017cej wy\u015bwietli si\u0119 interaktywwna wersja wykresu, obejmuj\u0105ca zadefiniowan\u0105 powy\u017cej liczb\u0119 punkt\u00f3w. Mo\u017cliwe jest zdefiniowanie i wy\u015bwietlanie kilku wykres\u00f3w. Warto wspomnie\u0107, \u017ce dla wykres\u00f3w z u\u017cyciem matplotlib zdefiniowano klas\u0119 konfiguracyjn\u0105, gdzie mo\u017cna ustali\u0107 parametry dotycz\u0105ce stylistyki wykres\u00f3w.</p>"},{"location":"adcs_pl/#testy","title":"Testy","text":"<p>Jako \u017ce to repozytorium ma bardziej charakter naukowy-in\u017cynierski, testy nie s\u0105 tutaj zaimplementowane w klasycznie programistycznym rozumieniu. Ich celem jest raczej u\u0142atwienie edycji, pozwalaj\u0105c upewni\u0107 si\u0119 co do dzia\u0142ania pewnych element\u00f3w kodu i upewnienia si\u0119, \u017ce ca\u0142e fragmenty zwracaj\u0105 warto\u015bci w oczekiwanym kszta\u0142cie. Mo\u017ce to pomaga\u0107 identyfikowa\u0107 potencjalne b\u0142\u0119dy powsta\u0142e w trakcie edycji. Uruchomienie test\u00f3w odbywa si\u0119 przy pomocy komendy:</p> <pre><code>pytest\n</code></pre> <p>Opcjonalnie warto przed uruchomieniem wyczy\u015bci\u0107 wpisy w terminalu. Taki zabieg poprawi czytelno\u015b\u0107 komunikatu.</p> <p>Opr\u00f3cz tego w pliku Jupyter Nootboowk examples.ipynb zamieszczone zosta\u0142y opisane w tym tek\u015bcie przek\u0142\u0105dy u\u017cycia poszczeg\u00f3lnych fragment\u00f3w. Ich poprawne wykonywanie si\u0119 r\u00f3wnie\u017c mo\u017ce by\u0107 u\u0142atwieniem i wskaz\u00f3wk\u0105 podczas prac rozwojowych.</p>"},{"location":"adcs_pl/#podsumowanie","title":"Podsumowanie","text":"<p>Stworzony kod jest baz\u0105 do dalszych modyfikacji i rozbudowy prostego systemu ADCS dla ma\u0142ego satelity; modu\u0142owa architektura u\u0142atwia dodawanie kolejnych sensor\u00f3w (np. czujnik horyzontu, czujnik\u00f3w gwiazd, pe\u0142ne IMU) oraz aktuator\u00f3w (np. ko\u0142a reakcyjne i hybryda cewk\u0105 elektromagnetyczna). Wymaga jeszcze dopracowania tryb pointing (B\u2011cross), w szczeg\u00f3lno\u015bci stabilno\u015bci, doboru wzmocnie\u0144 i logiki prze\u0142\u0105czania. Zach\u0119cam do korzystania, modyfikowania i inspirowania si\u0119 tym repozytorium we w\u0142asnych projektach. Je\u015bli zauwa\u017cysz b\u0142\u0105d lub masz propozycj\u0119 usprawnienia, ach\u0119cam do kontaktu.</p>"},{"location":"adcs_pl/#materiay","title":"Materia\u0142y","text":"<p>Poni\u017cej za\u0142\u0105czone zosta\u0142y materia\u0142y, kt\u00f3re by\u0142y na r\u00f3\u017cnym etapie pomocne w stworzeniu tej symulacji. Warto zwr\u00f3ci\u0107 uwag\u0119, \u017ce przy niekt\u00f3rych, konkretnych funkcjach zamieszczone zosta\u0142y linki do pomocnych materia\u0142\u00f3w odnosz\u0105cych si\u0119 bezpo\u015brednio do nich. Nie s\u0105 to oczywi\u015bcie wszystkie wykorzystane \u017ar\u00f3d\u0142a. Do niekt\u00f3rych zagadnie\u0144, szczeg\u00f3lnie zwi\u0105zanych z matematyk\u0105, transformacjami czy kodem, nieocenione okaza\u0142y si\u0119 w\u0105tki na r\u00f3\u017cnego rodzaju forach. W zagadnieniach stricte technicznych cz\u0119sto dobrymi opracowaniami pochwali\u0107 si\u0119 mo\u017ce angloj\u0119zyczna Wikipedia. Do pracy wykorzystane zosta\u0142y r\u00f3wnie\u017c modele j\u0119zykowe, zar\u00f3wno jako zewn\u0119trzny chat, jak i w formie GitHub Copilot.</p> <p>https://www.aero.iitb.acs/satelliteWiki/index.php/Main_Page https://automaticaddison.com/extended-kalman-filter-ekf-with-python-code-example/ https://digitalcommons.usu.edu/smallsat/2019/all2019/49/ https://www.diva-portal.org/smash/get/diva2:1018210/FULLTEXT02.pdf https://docs.advancednavigation.com/gnss-compass/Foundation%20Knowledge.htm https://files.core.ac.uk/download/pdf/286701577.pdf https://www.gov.br/inpe/pt-br/area-conhecimento/unidade-nordeste/conasat/documentacja/nano-satelites-pelo-mundo/aausat-3-aalborg-university-denmark/aausat-3-adcs-attitudedeterminationandcontrolsystem.pdf https://magneticearth.org/pages/models.html https://medium.com/@sasha_przybylski/the-math-behind-extended-kalman-filtering-0df981a87453 https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/Tutorials/pdf/individual_docs/17_frames_and_coordinate_systems.pdf https://quaternions.online/ https://probablydance.com/2017/08/05/intuitive-quaternions/ https://www.3dgep.com/understanding-quaternions/</p>"}]}